
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -D CPU=6502 -D INTERFACE=1 -b -L rom.lst -o rom.bin basic.asm
; Wed Aug 14 09:23:54 2019

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=6502					CPU=6502
=1					INTERFACE=1

;******  Processing input file: basic.asm

.0000	ea		nop				nop

;******  Processing file: data.asm

>0010					A_Mantissa	.dword ?						; floating point registers
>0014					A_Exponent	.byte ?							; showab.py is dependent on these being at $10,$18
>0015					A_Sign 		.byte ?
>0016					A_Zero 		.byte ?
>0017					A_Type 		.byte ?
>0018					B_Mantissa	.dword ?
>001c					B_Exponent	.byte ?
>001d					B_Sign 		.byte ?
>001e					B_Zero 		.byte ?
>001f					B_Type 		.byte ?
=$00					Type_Integer = $00 							; type IDs, not tested directly.
=$80					Type_Float = $80
=$40					Type_String = $40
>0020					zTemp1:		.word ?							; temporary pointers
>0022					zTemp2:		.word ?
>0024					zTemp3:		.word ?
>0026					zLTemp1:	.dword ?						; long word (used in multiply)
>002a					zGenPtr:	.word ? 						; general pointer.
>0300					Num_Buffer:	.fill 	32						; Buffer for number -> ASCII conversion
>0320					NumBufX:	.byte 	?						; Index into buffer for number -> ASCII conversion.
>0321					NumSuppress:.byte 	? 						; Buffer zero suppression flag.
>0322					ExpTemp:	.byte ? 						; Byte used in ASCII->number conversion.
>0323					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>0325					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>0327					Tim_SR:		.byte ? 						; Processor Status
>0328					Tim_A:		.byte ? 						; Processor Registers
>0329					Tim_X:		.byte ?
>032a					Tim_Y:		.byte ?
>032b					Tim_Z:		.byte ?
>032c					Tim_SP:		.byte ?							; Stack Pointer

;******  Return to file: basic.asm


;******  Processing file: interface/interface_emu.asm

=80					IF_Width 	= 80 							; characters across
=25					IF_Height 	= 25 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=6					IF_XPos 	= 6 							; current position, horizontal.
=$8000					IF_Screen = $8000							; 2k screen RAM here
=$8800					IF_PKeyboard = $8800						; Keyboard port.
=$8801					IF_PBreak = $8801 							; Break key.
.a000					IF_Reset:
.a000	60		rts				rts
.a001					IF_Home:
.a001	48		pha				pha
.a002	a9 00		lda #$00			lda 	#0	 						; zero X position
.a004	85 06		sta $06				sta 	IF_XPos
.a006	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.a008	85 04		sta $04				sta 	IF_Pos
.a00a	a9 80		lda #$80			lda 	#IF_Screen >> 8
.a00c	85 05		sta $05				sta 	IF_Pos+1
.a00e	68		pla				pla
.a00f	60		rts				rts
.a010					IF_NewLine:
.a010	48		pha				pha
.a011	a9 00		lda #$00			lda 	#0 							; back to start of line
.a013	85 06		sta $06				sta 	IF_XPos
.a015	18		clc				clc 								; down one line
.a016	a5 04		lda $04				lda 	IF_Pos
.a018	69 50		adc #$50			adc 	#80
.a01a	85 04		sta $04				sta 	IF_Pos
.a01c	90 02		bcc $a020			bcc 	_IF_NoCarry 				; carry through.
.a01e	e6 05		inc $05				inc 	IF_Pos+1
.a020					_IF_NoCarry:
.a020	68		pla				pla
.a021	60		rts				rts
.a022					IF_Read:
.a022	5a		phy				phy 								; save current Y
.a023	a4 06		ldy $06				ldy 	IF_XPos 					; read character at current position
.a025	b1 04		lda ($04),y			lda 	(IF_Pos),y
.a027	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a029	7a		ply				ply									; restore Y
.a02a	60		rts				rts
.a02b					IF_Write:
.a02b	5a		phy				phy 								; save current Y
.a02c	a4 06		ldy $06				ldy 	IF_XPos 					; write character at current position
.a02e	91 04		sta ($04),y			sta 	(IF_Pos),y
.a030	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a032	7a		ply				ply									; restore Y
.a033	60		rts				rts
.a034					IF_LeftOne:
.a034	c6 06		dec $06				dec 	IF_XPos
.a036	60		rts				rts
.a037					IF_CheckBreak:
.a037	ad 01 88	lda $8801			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.a03a	60		rts				rts
.a03b					IF_GetKey:
.a03b	ad 00 88	lda $8800			lda 	IF_PKeyboard				; read keyboard
.a03e	f0 07		beq $a047			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.a040	48		pha				pha 								; key pressed, clear queue.
.a041	a9 00		lda #$00			lda 	#0
.a043	8d 00 88	sta $8800			sta 	IF_PKeyboard
.a046	68		pla				pla
.a047					_IFGK_NoKey:
.a047	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.a049	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: interface/interface_tools.asm

=$200					IFT_XCursor = $200								; current logical position on screen
=$201					IFT_YCursor = $201
=$202					IFT_Buffer = $202 								; scroll copy buffer.
=$280					IFT_LineBuffer = $280 							; line input buffer.
.a04a					IFT_ClearScreen:
.a04a	48		pha				pha
.a04b	da		phx				phx
.a04c	5a		phy				phy
.a04d	20 01 a0	jsr $a001			jsr 	IF_Home 					; home cursor
.a050	a2 19		ldx #$19			ldx 	#IF_Height 					; this many lines.
.a052					_IFT_CS0:
.a052	a0 50		ldy #$50			ldy 	#IF_Width 					; this many chars/line
.a054					_IFT_CS1:
.a054	a9 20		lda #$20			lda 	#' '						; clear line.
.a056	20 2b a0	jsr $a02b			jsr 	IF_Write
.a059	88		dey				dey
.a05a	d0 f8		bne $a054			bne 	_IFT_CS1
.a05c	20 10 a0	jsr $a010			jsr 	IF_NewLine 					; next line down
.a05f	ca		dex				dex
.a060	d0 f0		bne $a052			bne 	_IFT_CS0
.a062	7a		ply				ply
.a063	fa		plx				plx
.a064	68		pla				pla
.a065					IFT_HomeCursor:
.a065	48		pha				pha
.a066	20 01 a0	jsr $a001			jsr 	IF_Home
.a069	a9 00		lda #$00			lda 	#0
.a06b	8d 00 02	sta $0200			sta 	IFT_XCursor
.a06e	8d 01 02	sta $0201			sta 	IFT_YCursor
.a071	68		pla				pla
.a072	60		rts				rts
.a073					IFT_UpLine:
.a073	48		pha				pha
.a074	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.a077	3a		dec a				dec 	a 							; line above
.a078	30 03		bmi $a07d			bmi 	_IFTULExit 					; too far, abort
.a07a	20 0a a1	jsr $a10a			jsr 	IFT_SetYPos					; set to that line.
.a07d					_IFTULExit:
.a07d	68		pla				pla
.a07e	60		rts				rts
.a07f					IFT_PrintCharacter:
.a07f	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.a081	f0 18		beq $a09b			beq 	IFT_NewLine
.a083	48		pha				pha
.a084	20 b3 a0	jsr $a0b3			jsr 	IFT_UpperCase 				; make upper case
.a087	29 3f		and #$3f			and 	#63 						; make 6 bit PETSCII
.a089	20 2b a0	jsr $a02b			jsr 	IF_Write 					; write out.
.a08c	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.a08f	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.a092	c9 50		cmp #$50			cmp 	#IF_Width
.a094	d0 03		bne $a099			bne 	_IFT_PCNotEOL
.a096	20 9b a0	jsr $a09b			jsr 	IFT_NewLine 				; if so do new line.
.a099					_IFT_PCNotEOL:
.a099	68		pla				pla
.a09a	60		rts				rts
.a09b					IFT_NewLine:
.a09b	48		pha				pha
.a09c	20 10 a0	jsr $a010			jsr 	IF_NewLine 					; new line on actual screen.
.a09f	a9 00		lda #$00			lda 	#0 							; reset x position
.a0a1	8d 00 02	sta $0200			sta 	IFT_XCursor
.a0a4	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.a0a7	ad 01 02	lda $0201			lda 	IFT_YCursor
.a0aa	c9 19		cmp #$19			cmp 	#IF_Height 					; reached bottom.
.a0ac	d0 03		bne $a0b1			bne 	_IFT_NL_NotEOS
.a0ae	20 be a0	jsr $a0be			jsr 	IFT_Scroll 					; scroll screen up.
.a0b1					_IFT_NL_NotEOS:
.a0b1	68		pla				pla
.a0b2	60		rts				rts
.a0b3					IFT_UpperCase:
.a0b3	c9 61		cmp #$61			cmp 	#"a"
.a0b5	90 06		bcc $a0bd			bcc 	_IFT_UCExit
.a0b7	c9 7b		cmp #$7b			cmp 	#"z"+1
.a0b9	b0 02		bcs $a0bd			bcs 	_IFT_UCExit
.a0bb	49 20		eor #$20			eor 	#$20
.a0bd					_IFT_UCExit:
.a0bd	60		rts				rts
.a0be					IFT_Scroll:
.a0be	48		pha				pha 								; save AXY
.a0bf	da		phx				phx
.a0c0	5a		phy				phy
.a0c1	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.a0c3					_IFT_SLoop:
.a0c3	20 e3 a0	jsr $a0e3			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.a0c6	e8		inx				inx
.a0c7	e0 18		cpx #$18			cpx 	#IF_Height-1				; do whole screen
.a0c9	d0 f8		bne $a0c3			bne 	_IFT_SLoop
.a0cb	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a0cd	20 0a a1	jsr $a10a			jsr 	IFT_SetYPos
.a0d0	a2 50		ldx #$50			ldx 	#IF_Width 					; blank line
.a0d2					_IFT_SBlank:
.a0d2	a9 20		lda #$20			lda 	#32
.a0d4	20 2b a0	jsr $a02b			jsr 	IF_Write
.a0d7	ca		dex				dex
.a0d8	d0 f8		bne $a0d2			bne 	_IFT_SBlank
.a0da	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a0dc	20 0a a1	jsr $a10a			jsr 	IFT_SetYPos
.a0df	7a		ply				ply
.a0e0	fa		plx				plx
.a0e1	68		pla				pla
.a0e2	60		rts				rts
.a0e3					_IFT_ScrollLine:
.a0e3	da		phx				phx
.a0e4	da		phx				phx
.a0e5	8a		txa				txa 								; copy line into buffer.
.a0e6	1a		inc a				inc 	a 							; next line down.
.a0e7	20 0a a1	jsr $a10a			jsr 	IFT_SetYPos
.a0ea	a2 00		ldx #$00			ldx 	#0
.a0ec					_IFTScrollCopy1:
.a0ec	20 22 a0	jsr $a022			jsr 	IF_Read
.a0ef	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.a0f2	e8		inx				inx
.a0f3	e0 50		cpx #$50			cpx 	#IF_Width
.a0f5	d0 f5		bne $a0ec			bne 	_IFTScrollCopy1
.a0f7	68		pla				pla
.a0f8	20 0a a1	jsr $a10a			jsr 	IFT_SetYPos
.a0fb	a2 00		ldx #$00			ldx 	#0
.a0fd					_IFTScrollCopy2:
.a0fd	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.a100	20 2b a0	jsr $a02b			jsr 	IF_Write
.a103	e8		inx				inx
.a104	e0 50		cpx #$50			cpx 	#IF_Width
.a106	d0 f5		bne $a0fd			bne 	_IFTScrollCopy2
.a108	fa		plx				plx
.a109	60		rts				rts
.a10a					IFT_SetYPos:
.a10a	48		pha				pha
.a10b	da		phx				phx
.a10c	aa		tax				tax
.a10d	20 65 a0	jsr $a065			jsr 	IFT_HomeCursor
.a110	e0 00		cpx #$00			cpx 	#0
.a112	f0 09		beq $a11d			beq 	_IFT_MOAExit
.a114					_IFT_MOALoop:
.a114	20 10 a0	jsr $a010			jsr 	IF_NewLine
.a117	ee 01 02	inc $0201			inc 	IFT_YCursor
.a11a	ca		dex				dex
.a11b	d0 f7		bne $a114			bne		_IFT_MOALoop
.a11d					_IFT_MOAExit:
.a11d	fa		plx				plx
.a11e	68		pla				pla
.a11f	60		rts				rts
.a120					IFT_GetKeyCursor:
.a120	20 28 a1	jsr $a128			jsr 	_IFT_FlipCursor 			; reverse current
.a123					_IFT_GKCWait:
.a123	20 3b a0	jsr $a03b			jsr 	IF_GetKey 					; get key
.a126	f0 fb		beq $a123			beq 	_IFT_GKCWait
.a128					_IFT_FlipCursor:
.a128	48		pha				pha 								; save
.a129	20 22 a0	jsr $a022			jsr 	IF_Read 					; read
.a12c	20 34 a0	jsr $a034			jsr 	IF_LeftOne
.a12f	49 80		eor #$80			eor 	#$80 						; reverse
.a131	20 2b a0	jsr $a02b			jsr 	IF_Write 					; write
.a134	20 34 a0	jsr $a034			jsr 	IF_LeftOne
.a137	68		pla				pla
.a138	60		rts				rts
.a139					IFT_ReadLine:
.a139	48		pha				pha
.a13a					_IFT_RLLoop:
.a13a	20 20 a1	jsr $a120			jsr 	IFT_GetKeyCursor 			; get keystroke
.a13d	c9 0d		cmp #$0d			cmp 	#13							; return
.a13f	f0 7d		beq $a1be			beq 	_IFT_RLExit
.a141	c9 20		cmp #$20			cmp 	#32 						; control character
.a143	90 05		bcc $a14a			bcc 	_IFT_Control
.a145	20 7f a0	jsr $a07f			jsr 	IFT_PrintCharacter
.a148	80 f0		bra $a13a			bra 	_IFT_RLLoop
.a14a					_IFT_Control:
.a14a	c9 01		cmp #$01			cmp 	#"A"-64
.a14c	f0 26		beq $a174			beq 	_IFT_Left
.a14e	c9 04		cmp #$04			cmp 	#"D"-64
.a150	f0 2e		beq $a180			beq 	_IFT_Right
.a152	c9 17		cmp #$17			cmp 	#"W"-64
.a154	f0 36		beq $a18c			beq 	_IFT_Up
.a156	c9 13		cmp #$13			cmp 	#"S"-64
.a158	f0 3e		beq $a198			beq 	_IFT_Down
.a15a	c9 08		cmp #$08			cmp 	#"H"-64
.a15c	f0 09		beq $a167			beq 	_IFT_Backspace
.a15e	c9 1a		cmp #$1a			cmp 	#"Z"-64
.a160	d0 d8		bne $a13a			bne 	_IFT_RLLoop
.a162	20 4a a0	jsr $a04a			jsr 	IFT_ClearScreen				; clear CTL-Z
.a165	80 d3		bra $a13a			bra 	_IFT_RLLoop
.a167					_IFT_Backspace:
.a167	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.a16a	f0 ce		beq $a13a			beq 	_IFT_RLLoop
.a16c	20 34 a0	jsr $a034			jsr 	IF_LeftOne
.a16f	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.a171	20 2b a0	jsr $a02b			jsr 	IF_Write
.a174					_IFT_Left:
.a174	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.a177	10 29		bpl $a1a2			bpl 	_IFT_Reposition
.a179	a9 4f		lda #$4f			lda 	#IF_Width-1
.a17b					_IFT_SetX:
.a17b	8d 00 02	sta $0200			sta 	IFT_XCursor
.a17e	80 22		bra $a1a2			bra 	_IFT_Reposition
.a180					_IFT_Right:
.a180	ee 00 02	inc $0200			inc 	IFT_XCursor
.a183	ad 00 02	lda $0200			lda 	IFT_XCursor
.a186	49 50		eor #$50			eor 	#IF_Width
.a188	f0 f1		beq $a17b			beq 	_IFT_SetX
.a18a	80 16		bra $a1a2			bra 	_IFT_Reposition
.a18c					_IFT_Up:
.a18c	ce 01 02	dec $0201			dec 	IFT_YCursor
.a18f	10 11		bpl $a1a2			bpl 	_IFT_Reposition
.a191	a9 18		lda #$18			lda 	#IF_Height-1
.a193					_IFT_SetY:
.a193	8d 01 02	sta $0201			sta 	IFT_YCursor
.a196	80 0a		bra $a1a2			bra 	_IFT_Reposition
.a198					_IFT_Down:
.a198	ee 01 02	inc $0201			inc 	IFT_YCursor
.a19b	ad 01 02	lda $0201			lda 	IFT_YCursor
.a19e	49 19		eor #$19			eor 	#IF_Height
.a1a0	f0 f1		beq $a193			beq 	_IFT_SetY
.a1a2					_IFT_Reposition:
.a1a2	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.a1a5	48		pha				pha
.a1a6	ad 01 02	lda $0201			lda 	IFT_YCursor
.a1a9	20 0a a1	jsr $a10a			jsr 	IFT_SetYPos
.a1ac	68		pla				pla
.a1ad	aa		tax				tax
.a1ae	e0 00		cpx #$00			cpx 	#0
.a1b0	f0 88		beq $a13a			beq 	_IFT_RLLoop
.a1b2					_IFT_MoveRight:
.a1b2	20 22 a0	jsr $a022			jsr 	IF_Read
.a1b5	ee 00 02	inc $0200			inc 	IFT_XCursor
.a1b8	ca		dex				dex
.a1b9	d0 f7		bne $a1b2			bne 	_IFT_MoveRight
.a1bb	4c 3a a1	jmp $a13a			jmp 	_IFT_RLLoop
.a1be					_IFT_RLExit:
.a1be	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.a1c1	20 0a a1	jsr $a10a			jsr 	IFT_SetYPos
.a1c4	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.a1c6					_IFT_RLRead:
.a1c6	20 22 a0	jsr $a022			jsr 	IF_Read
.a1c9	18		clc				clc 								; convert back to ASCII.
.a1ca	49 20		eor #$20			eor 	#$20
.a1cc	69 20		adc #$20			adc 	#$20
.a1ce	9d 80 02	sta $0280,x			sta 	IFT_LineBuffer,x
.a1d1	e8		inx				inx
.a1d2	e0 50		cpx #$50			cpx 	#IF_Width
.a1d4	d0 f0		bne $a1c6			bne 	_IFT_RLRead
.a1d6					_IFT_RL_Trim:
.a1d6	ca		dex				dex 	 							; previous char
.a1d7	30 07		bmi $a1e0			bmi 	_IFT_Found 					; gone too far
.a1d9	bd 80 02	lda $0280,x			lda 	IFT_LineBuffer,x			; go back if space
.a1dc	c9 20		cmp #$20			cmp 	#" "
.a1de	f0 f6		beq $a1d6			beq 	_IFT_RL_Trim
.a1e0					_IFT_Found:
.a1e0	e8		inx				inx 								; forward to non-space
.a1e1	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.a1e3	9d 80 02	sta $0280,x			sta 	IFT_LineBuffer,x
.a1e6	68		pla				pla
.a1e7	a2 80		ldx #$80			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.a1e9	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.a1eb	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: utility/tim.asm

.a1ec					TIM_Error:
.a1ec	20 73 a0	jsr $a073			jsr 	IFT_UpLine 					; go up one line.
.a1ef	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.a1f1	80 02		bra $a1f5			bra 	TIM_ShowPrompt
.a1f3					TIM_NewCommand:
.a1f3	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.a1f5					TIM_ShowPrompt:
.a1f5	20 7f a0	jsr $a07f			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.a1f8	20 39 a1	jsr $a139			jsr 	IFT_ReadLine	 			; get character, go to next line
.a1fb	20 9b a0	jsr $a09b			jsr 	IFT_NewLine					; go to next line.
.a1fe	86 20		stx $20				stx 	zTemp1 						; save line read address
.a200	84 21		sty $21				sty 	zTemp1+1
.a202	a0 01		ldy #$01			ldy 	#1 							; get first character after the prompt.
.a204	b1 20		lda ($20),y			lda 	(zTemp1),y
.a206	c9 52		cmp #$52			cmp 	#"R"						; show registers
.a208	f0 6b		beq $a275			beq 	TIM_ShowRegisters
.a20a	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.a20c	f0 12		beq $a220			beq 	TIM_ShowMemory
.a20e	c9 47		cmp #$47			cmp 	#"G"						; execute
.a210	f0 49		beq $a25b			beq 	TIM_Execute
.a212	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.a214	f0 07		beq $a21d			beq 	TIM_GoLoadMemory
.a216	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.a218	d0 d2		bne $a1ec			bne 	TIM_Error
.a21a	4c 96 a3	jmp $a396			jmp 	TIM_UpdateRegisters
.a21d					TIM_GoLoadMemory:
.a21d	4c c1 a3	jmp $a3c1			jmp 	TIM_LoadMemory
.a220					TIM_ShowMemory:
.a220	20 12 a3	jsr $a312			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.a223	b0 c7		bcs $a1ec			bcs 	TIM_Error
.a225	a5 24		lda $24				lda 	zTemp3 						; copy zTemp3 => zTemp2
.a227	85 22		sta $22				sta 	zTemp2
.a229	a5 25		lda $25				lda 	zTemp3+1
.a22b	85 23		sta $23				sta 	zTemp2+1
.a22d	20 12 a3	jsr $a312			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.a230	90 08		bcc $a23a			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.a232	a5 22		lda $22				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.a234	85 24		sta $24				sta 	zTemp3
.a236	a5 23		lda $23				lda 	zTemp2+1
.a238	85 25		sta $25				sta 	zTemp3+1
.a23a					_TIMSM_Start:
.a23a	20 ea a2	jsr $a2ea			jsr 	TIM_WriteLine 				; write one line of hex out
.a23d	a5 22		lda $22				lda 	zTemp2 						; bump ZTemp2 by 16
.a23f	18		clc				clc
.a240	69 10		adc #$10			adc 	#16
.a242	85 22		sta $22				sta 	zTemp2
.a244	90 02		bcc $a248			bcc 	_TIMSM_NoCarry
.a246	e6 23		inc $23				inc 	zTemp2+1
.a248					_TIMSM_NoCarry:
.a248	20 37 a0	jsr $a037			jsr 	IF_CheckBreak 				; check CTL+C
.a24b	d0 0b		bne $a258			bne 	_TIMSM_Ends 				; if pressed break out.
.a24d	38		sec				sec 								; check past the end address in zTemp3
.a24e	a5 24		lda $24				lda 	zTemp3
.a250	e5 22		sbc $22				sbc 	zTemp2
.a252	a5 25		lda $25				lda 	zTemp3+1
.a254	e5 23		sbc $23				sbc 	zTemp2+1
.a256	10 e2		bpl $a23a			bpl 	_TIMSM_Start
.a258					_TIMSM_Ends:
.a258	4c f3 a1	jmp $a1f3			jmp 	TIM_NewCommand
.a25b					TIM_Execute:
.a25b	20 12 a3	jsr $a312			jsr 	TIM_GetHex 					; get the execute address
.a25e	b0 8c		bcs $a1ec			bcs 	TIM_Error 					; not legitimate
.a260	ae 2c 03	ldx $032c			ldx 	TIM_SP 						; set up SP
.a263	9a		txs				txs
.a264	ad 27 03	lda $0327			lda 	TIM_SR 						; Status for PLP
.a267	48		pha				pha
.a268	ad 28 03	lda $0328			lda 	TIM_A 						; restore AXYZ
.a26b	ae 29 03	ldx $0329			ldx 	TIM_X
.a26e	ac 2a 03	ldy $032a			ldy 	TIM_Y
.a271	28		plp				plp 								; and PS Byte.
.a272	6c 24 00	jmp ($0024)			jmp 	(zTemp3)					; go execute
.a275					TIM_Start:
.a275					TIM_ShowRegisters:
.a275	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.a278	8d 26 03	sta $0326			sta 	TIM_IRQ+1
.a27b	ad ff ff	lda $ffff			lda 	$FFFF
.a27e	8d 25 03	sta $0325			sta 	TIM_IRQ
.a281	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.a283					_TIMSR_Text:
.a283	bd ae a2	lda $a2ae,x			lda 	_TIMSR_Label,x
.a286	20 7f a0	jsr $a07f			jsr 	IFT_PrintCharacter
.a289	e8		inx				inx
.a28a	e0 23		cpx #$23			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.a28c	d0 f5		bne $a283			bne 	_TIMSR_Text
.a28e	a2 00		ldx #$00			ldx 	#0 							; output Register Line.
.a290					_TIMSR_LoopSpace:
.a290	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.a292	b0 04		bcs $a298			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.a294	8a		txa				txa
.a295	4a		lsr a				lsr 	a
.a296	b0 05		bcs $a29d			bcs 	_TIMSR_NoSpace
.a298					_TIMSR_Space:
.a298	a9 20		lda #$20			lda 	#" "
.a29a	20 7f a0	jsr $a07f			jsr 	IFT_PrintCharacter
.a29d					_TIMSR_NoSpace:
.a29d	bd 23 03	lda $0323,x			lda 	TIM_PC,x 					; output hex value.
.a2a0	20 d1 a2	jsr $a2d1			jsr 	TIM_WriteHex
.a2a3	e8		inx				inx
.a2a4	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.a2a6	d0 e8		bne $a290			bne 	_TimSR_LoopSpace
.a2a8	20 9b a0	jsr $a09b			jsr 	IFT_NewLine 				; new line
.a2ab	4c f3 a1	jmp $a1f3			jmp	 	TIM_NewCommand 				; new command.
.a2ae					_TIMSR_Label:
>a2ae	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR ZR SP",13,".; "
>a2b6	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>a2c6	52 20 5a 52 20 53 50 0d 2e 3b 20
.a2d1					_TIMSR_LabelEnd:
.a2d1					TIM_WriteHex:
.a2d1	48		pha				pha 								; save A
.a2d2	4a		lsr a				lsr 	a 							; shift MSB->LSB
.a2d3	4a		lsr a				lsr 	a
.a2d4	4a		lsr a				lsr 	a
.a2d5	4a		lsr a				lsr 	a
.a2d6	20 da a2	jsr $a2da			jsr 	_TIMWH_Nibble 				; print MSB
.a2d9	68		pla				pla 								; restore and print LSB
.a2da					_TIMWH_Nibble:
.a2da	48		pha				pha
.a2db	29 0f		and #$0f			and 	#15 						; mask out
.a2dd	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.a2df	90 02		bcc $a2e3			bcc 	_TIMWHNoLetter
.a2e1	69 06		adc #$06			adc 	#6
.a2e3					_TIMWHNoLetter:
.a2e3	69 30		adc #$30			adc 	#48
.a2e5	20 7f a0	jsr $a07f			jsr 	IFT_PrintCharacter 			; print it out.
.a2e8	68		pla				pla
.a2e9	60		rts				rts
.a2ea					TIM_WriteLine:
.a2ea	a9 2e		lda #$2e			lda 	#"." 						; prompt
.a2ec	20 7f a0	jsr $a07f			jsr 	IFT_PrintCharacter
.a2ef	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.a2f1	20 7f a0	jsr $a07f			jsr 	IFT_PrintCharacter
.a2f4	a5 23		lda $23				lda 	zTemp2+1 					; write address
.a2f6	20 d1 a2	jsr $a2d1			jsr 	TIM_WriteHex
.a2f9	a5 22		lda $22				lda 	zTemp2
.a2fb	20 d1 a2	jsr $a2d1			jsr 	TIM_WriteHex
.a2fe	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.a300					_TIMWL_Loop:
.a300	a9 20		lda #$20			lda 	#" "
.a302	20 7f a0	jsr $a07f			jsr 	IFT_PrintCharacter
.a305	b1 22		lda ($22),y			lda 	(zTemp2),y
.a307	20 d1 a2	jsr $a2d1			jsr 	TIM_WriteHex
.a30a	c8		iny				iny
.a30b	c0 10		cpy #$10			cpy 	#16
.a30d	d0 f1		bne $a300			bne 	_TIMWL_Loop
.a30f	4c 9b a0	jmp $a09b			jmp 	IFT_NewLine 				; new line and exit
.a312					TIM_GetHex:
.a312	c8		iny				iny
.a313	b1 20		lda ($20),y			lda 	(zTemp1),y 					; skip over spaces.
.a315	c9 20		cmp #$20			cmp 	#32
.a317	f0 f9		beq $a312			beq 	TIM_GetHex
.a319	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.a31b	f0 f5		beq $a312			beq 	TIM_GetHex
.a31d	20 46 a3	jsr $a346			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.a320	b0 23		bcs $a345			bcs 	_TIMGH_Exit					; if first bad then exit now.
.a322	a9 00		lda #$00			lda 	#0 							; zero result
.a324	85 24		sta $24				sta 	zTemp3
.a326	85 25		sta $25				sta 	zTemp3+1
.a328					_TIM_GHLoop:
.a328	20 46 a3	jsr $a346			jsr 	TIM_GetHexCharacter 		; get next character
.a32b	b0 17		bcs $a344			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.a32d	c8		iny				iny 								; skip over it.
.a32e	06 24		asl $24				asl 	zTemp3 						; x zTemp3 by 16
.a330	26 25		rol $25				rol 	zTemp3+1
.a332	06 24		asl $24				asl 	zTemp3 						; now x 2
.a334	26 25		rol $25				rol 	zTemp3+1
.a336	06 24		asl $24				asl 	zTemp3						; now x 4
.a338	26 25		rol $25				rol 	zTemp3+1
.a33a	06 24		asl $24				asl 	zTemp3 						; now x 8
.a33c	26 25		rol $25				rol 	zTemp3+1
.a33e	05 24		ora $24				ora 	zTemp3 						; OR result in
.a340	85 24		sta $24				sta 	zTemp3
.a342	80 e4		bra $a328			bra 	_TIM_GHLoop 				; loop round again.
.a344					_TIMGH_Okay:
.a344	18		clc				clc
.a345					_TIMGH_Exit:
.a345	60		rts				rts
.a346					TIM_GetHexCharacter:
.a346	b1 20		lda ($20),y			lda 	(zTemp1),y
.a348	38		sec				sec
.a349	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.a34b	90 0e		bcc $a35b			bcc 	_TIM_GHCFail
.a34d	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.a34f	90 0b		bcc $a35c			bcc 	_TIM_GHCExit
.a351	c9 11		cmp #$11			cmp 	#65-48						; < A
.a353	90 06		bcc $a35b			bcc		_TIM_GHCFail
.a355	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.a357	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.a359	90 01		bcc $a35c			bcc		_TIM_GHCExit
.a35b					_TIM_GHCFail:
.a35b	38		sec				sec
.a35c					_TIM_GHCExit:
.a35c	60		rts				rts
.a35d					TIM_BreakVector:
.a35d	da		phx				phx									; save X/A on stack
.a35e	48		pha				pha
.a35f	ba		tsx				tsx 								; X points to S
.a360	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.a363	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.a365	d0 03		bne $a36a			bne 	_TIMBreak					; if set, it's BRK
.a367	68		pla				pla 								; abandon routine.
.a368	fa		plx				plx
.a369	40		rti				rti
.a36a					_TIMBreak:
.a36a	68		pla				pla 								; save A X Y and maybe Z
.a36b	8d 28 03	sta $0328			sta 	TIM_A
.a36e	fa		plx				plx
.a36f	8e 29 03	stx $0329			stx 	TIM_X
.a372	8c 2a 03	sty $032a			sty 	TIM_Y
.a375	68		pla				pla 								; get Status Register
.a376	8d 27 03	sta $0327			sta 	TIM_SR
.a379	68		pla				pla
.a37a	8d 24 03	sta $0324			sta 	TIM_PC+1 					; save calling address
.a37d	68		pla				pla
.a37e	8d 23 03	sta $0323			sta 	TIM_PC 						; high byte
.a381	ad 24 03	lda $0324			lda 	TIM_PC+1 					; dec PC to point right.
.a384	d0 03		bne $a389			bne 	_TIMDecrement 				; brk bumps it.
.a386	ce 23 03	dec $0323			dec 	TIM_PC
.a389					_TIMDecrement:
.a389	ce 24 03	dec $0324			dec 	TIM_PC+1
.a38c	ba		tsx				tsx 								; and copy SP
.a38d	8e 2c 03	stx $032c			stx 	TIM_SP
.a390	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.a392	9a		txs				txs
.a393	4c 75 a2	jmp $a275			jmp 	TIM_Start 					; and start up TIM monitor.
.a396					TIM_UpdateRegisters:
.a396	20 12 a3	jsr $a312			jsr 	TIM_GetHex 					; PC
.a399	b0 23		bcs $a3be			bcs 	_TIMURFail
.a39b	a5 24		lda $24				lda 	zTemp3
.a39d	8d 24 03	sta $0324			sta 	Tim_PC+1
.a3a0	a5 25		lda $25				lda 	zTemp3+1
.a3a2	8d 23 03	sta $0323			sta 	Tim_PC
.a3a5	20 12 a3	jsr $a312			jsr 	TIM_GetHex 					; ignore IRQ
.a3a8	b0 14		bcs $a3be			bcs 	_TIMURFail
.a3aa	a2 00		ldx #$00			ldx 	#0
.a3ac					_TIM_URLoop:
.a3ac	20 12 a3	jsr $a312			jsr 	TIM_GetHex 					; registers
.a3af	b0 0d		bcs $a3be			bcs 	_TIMURFail
.a3b1	a5 24		lda $24				lda 	zTemp3
.a3b3	9d 27 03	sta $0327,x			sta 	Tim_SR,x
.a3b6	e8		inx				inx
.a3b7	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.a3b9	d0 f1		bne $a3ac			bne 	_TIM_URLoop
.a3bb	4c f3 a1	jmp $a1f3			jmp 	TIM_NewCommand
.a3be					_TIMURFail:
.a3be	4c ec a1	jmp $a1ec			jmp 	TIM_Error
.a3c1					TIM_LoadMemory:
.a3c1	20 12 a3	jsr $a312			jsr 	TIM_GetHex 					; target address => zTemp2
.a3c4	a5 24		lda $24				lda 	zTemp3
.a3c6	85 22		sta $22				sta 	zTemp2
.a3c8	a5 25		lda $25				lda 	zTemp3+1
.a3ca	85 23		sta $23				sta 	zTemp2+1
.a3cc					_TIM_LMLoop:
.a3cc	20 12 a3	jsr $a312			jsr 	TIM_GetHex 					; next byte ?
.a3cf	b0 0e		bcs $a3df			bcs 	_TIMLMDone 					; no more
.a3d1	a2 00		ldx #$00			ldx 	#0							; write out.
.a3d3	a5 24		lda $24				lda 	zTemp3
.a3d5	81 22		sta ($22,x)			sta 	(zTemp2,x)
.a3d7	e6 22		inc $22				inc 	zTemp2 						; bump address
.a3d9	d0 f1		bne $a3cc			bne 	_TIM_LMLoop
.a3db	e6 23		inc $23				inc 	zTemp2+1
.a3dd	80 ed		bra $a3cc			bra 	_TIM_LMLoop
.a3df					_TIMLMDone:
.a3df	4c f3 a1	jmp $a1f3			jmp 	TIM_NewCommand

;******  Return to file: basic.asm


;******  Processing file: arithmetic/fpmacros.asm


;******  Return to file: basic.asm


;******  Processing file: arithmetic/fputils.asm

.a3e2					FPUSetAFromXY:
.a3e2	48		pha				pha
.a3e3	86 10		stx $10				stx 	A_Mantissa 					; set the lower 2 bytes
.a3e5	84 11		sty $11				sty 	A_Mantissa+1
.a3e7	98		tya				tya
.a3e8	0a		asl a				asl 	a 							; CS if MSB set.
.a3e9	a9 00		lda #$00			lda 	#0 							; 0 if CC,$FF if CS
.a3eb	90 01		bcc $a3ee			bcc 	_FPUSB1
.a3ed	3a		dec a				dec 	a
.a3ee	85 12		sta $12		_FPUSB1:sta 	A_Mantissa+2 				; these are the two ms bytes
.a3f0	85 13		sta $13				sta 	A_Mantissa+3
.a3f2	a9 00		lda #$00			lda 	#Type_Integer 				; type is integer.
.a3f4	85 17		sta $17				sta 	A_Type
.a3f6	68		pla				pla
.a3f7	60		rts				rts
.a3f8					FPUSetBFromXY:
.a3f8	48		pha				pha
.a3f9	86 18		stx $18				stx 	B_Mantissa 					; set the lower 2 bytes
.a3fb	84 19		sty $19				sty 	B_Mantissa+1
.a3fd	98		tya				tya
.a3fe	0a		asl a				asl 	a 							; CS if MSB set.
.a3ff	a9 00		lda #$00			lda 	#0 							; 0 if CC,$FF if CS
.a401	90 01		bcc $a404			bcc 	_FPUSB1
.a403	3a		dec a				dec 	a
.a404	85 1a		sta $1a		_FPUSB1:sta 	B_Mantissa+2 				; these are the two ms bytes
.a406	85 1b		sta $1b				sta 	B_Mantissa+3
.a408	a9 00		lda #$00			lda 	#Type_Integer 				; type is integer.
.a40a	85 1f		sta $1f				sta 	B_Type
.a40c	68		pla				pla
.a40d	60		rts				rts
.a40e					FPUCopyAToB:
.a40e	48		pha				pha 								; copy the 8 byte format across.
.a40f	da		phx				phx
.a410	a2 07		ldx #$07			ldx 	#7
.a412					_FPUCopy2:
.a412	b5 10		lda $10,x			lda 	A_Mantissa,x
.a414	95 18		sta $18,x			sta 	B_Mantissa,x
.a416	ca		dex				dex
.a417	10 f9		bpl $a412			bpl 	_FPUCopy2
.a419	fa		plx				plx
.a41a	68		pla				pla
.a41b	60		rts				rts
.a41c					FPUCopyBToA:
.a41c	48		pha				pha 								; copy the 8 byte format across.
.a41d	da		phx				phx
.a41e	a2 07		ldx #$07			ldx 	#7
.a420					_FPUCopy1:
.a420	b5 18		lda $18,x			lda 	B_Mantissa,x
.a422	95 10		sta $10,x			sta 	A_Mantissa,x
.a424	ca		dex				dex
.a425	10 f9		bpl $a420			bpl 	_FPUCopy1
.a427	fa		plx				plx
.a428	68		pla				pla
.a429	60		rts				rts
.a42a					FPUToFloatX:
.a42a	48		pha				pha
.a42b	b5 17		lda $17,x			lda 	A_Type,x					; exit if already float.
.a42d	30 26		bmi $a455			bmi 	_FPUBExit
.a42f	a9 80		lda #$80			lda 	#Type_Float 				; set float type
.a431	95 17		sta $17,x			sta 	A_Type,x
.a433	a9 20		lda #$20			lda 	#32 						; and the exponent to 32, makes it * 2^32
.a435	95 14		sta $14,x			sta 	A_Exponent,x
.a437	a9 00		lda #$00			lda 	#0 							; clear sign/zero bytes
.a439	95 15		sta $15,x			sta 	A_Sign,x
.a43b	95 16		sta $16,x			sta		A_Zero,x
.a43d	b5 13		lda $13,x			lda 	A_Mantissa+3,x 				; signed integer ?
.a43f	10 05		bpl $a446			bpl		_FPUBPositive
.a441	20 1e a5	jsr $a51e			jsr 	FPUIntegerNegateX 			; do B = -B in integer, so +ve mantissa
.a444	d6 15		dec $15,x			dec 	A_Sign,x 					; set the sign byte to $FF
.a446					_FPUBPositive:
.a446	b5 10		lda $10,x			lda 	A_Mantissa,x 				; mantissa is zero ?
.a448	15 11		ora $11,x			ora 	A_Mantissa+1,x
.a44a	15 12		ora $12,x			ora 	A_Mantissa+2,x
.a44c	15 13		ora $13,x			ora 	A_Mantissa+3,x
.a44e	d0 02		bne $a452			bne 	_FPUBNonZero
.a450	d6 16		dec $16,x			dec 	A_Zero,x 					; set the zero byte to $FF
.a452					_FPUBNonZero:
.a452	20 01 a5	jsr $a501			jsr 	FPUNormaliseX
.a455					_FPUBExit:
.a455	68		pla				pla
.a456	60		rts				rts
.a457					FPUAToInteger:
.a457	48		pha				pha
.a458	a5 17		lda $17				lda 	A_Type 						; if already integer, exit
.a45a	f0 39		beq $a495			beq 	_FPUATOI_Exit
.a45c	a9 00		lda #$00			lda 	#Type_Integer 				; make type zero (integer)
.a45e	85 17		sta $17				sta 	A_Type
.a460	a5 16		lda $16				lda 	A_Zero						; if zero, return zero.
.a462	d0 27		bne $a48b			bne 	_FPUATOI_Zero
.a464	a5 14		lda $14				lda 	A_Exponent 					; check -ve exponent or < 32
.a466	30 04		bmi $a46c			bmi 	_FPUAToIOk
.a468	c9 20		cmp #$20			cmp 	#32 						; sign exponent >= 32, overflow.
.a46a	b0 2b		bcs $a497			bcs 	FP_Overflow
.a46c					_FPUAToIOk:
.a46c					_FPUAToIToInteger:
.a46c	a5 14		lda $14				lda 	A_Exponent 					; reached ^32
.a46e	c9 20		cmp #$20			cmp 	#32
.a470	f0 0c		beq $a47e			beq 	_FPUAtoICheckSign 			; check sign needs fixing up.
.a472	e6 14		inc $14				inc 	A_Exponent 					; increment Exponent
.a474	46 13		lsr $13				lsr 	3+A_Mantissa
.a476	66 12		ror $12				ror 	2+A_Mantissa
.a478	66 11		ror $11				ror 	1+A_Mantissa
.a47a	66 10		ror $10				ror 	0+A_Mantissa
.a47c	80 ee		bra $a46c			bra 	_FPUAToIToInteger 			; keep going.
.a47e					_FPUAtoICheckSign:
.a47e	a5 15		lda $15				lda 	A_Sign 						; check sign
.a480	f0 13		beq $a495			beq 	_FPUAToI_Exit 				; exit if unsigned.
.a482	da		phx				phx
.a483	a2 00		ldx #$00			ldx 	#0
.a485	20 1e a5	jsr $a51e			jsr 	FPUIntegerNegateX 			; otherwise negate the shifted mantissa
.a488	fa		plx				plx
.a489	80 0a		bra $a495			bra 	_FPUATOI_Exit
.a48b					_FPUATOI_Zero:
.a48b	a9 00		lda #$00			lda 	#0 							; return zero integer.
.a48d	85 10		sta $10				sta 	A_Mantissa+0
.a48f	85 11		sta $11				sta 	A_Mantissa+1
.a491	85 12		sta $12				sta 	A_Mantissa+2
.a493	85 13		sta $13				sta 	A_Mantissa+3
.a495					_FPUATOI_Exit:
.a495	68		pla				pla
.a496	60		rts				rts
.a497					FP_Overflow:
.a497	20 5a a9	jsr $a95a			jsr 	ERR_Handler
>a49a	46 6c 6f 61 74 69 6e 67				.text 	"Floating Point overflow",0
>a4a2	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.a4b2					FPUTimes10X:
.a4b2	b5 10		lda $10,x			lda 	A_Mantissa+0,x 				; copy mantissa to ZLTemp1
.a4b4	85 26		sta $26				sta 	ZLTemp1+0
.a4b6	b5 11		lda $11,x			lda 	A_Mantissa+1,x
.a4b8	85 27		sta $27				sta 	ZLTemp1+1
.a4ba	b5 12		lda $12,x			lda 	A_Mantissa+2,x
.a4bc	85 28		sta $28				sta 	ZLTemp1+2
.a4be	b5 13		lda $13,x			lda 	A_Mantissa+3,x
.a4c0	85 29		sta $29				sta 	ZLTemp1+3
.a4c2	46 29		lsr $29				lsr 	3+ZLTemp1
.a4c4	66 28		ror $28				ror 	2+ZLTemp1
.a4c6	66 27		ror $27				ror 	1+ZLTemp1
.a4c8	66 26		ror $26				ror 	0+ZLTemp1
.a4ca	46 29		lsr $29				lsr 	3+ZLTemp1
.a4cc	66 28		ror $28				ror 	2+ZLTemp1
.a4ce	66 27		ror $27				ror 	1+ZLTemp1
.a4d0	66 26		ror $26				ror 	0+ZLTemp1
.a4d2	18		clc				clc
.a4d3	b5 10		lda $10,x			lda 	A_Mantissa+0,x
.a4d5	65 26		adc $26				adc 	ZLTemp1+0
.a4d7	95 10		sta $10,x			sta 	A_Mantissa+0,x
.a4d9	b5 11		lda $11,x			lda 	A_Mantissa+1,x
.a4db	65 27		adc $27				adc 	ZLTemp1+1
.a4dd	95 11		sta $11,x			sta 	A_Mantissa+1,x
.a4df	b5 12		lda $12,x			lda 	A_Mantissa+2,x
.a4e1	65 28		adc $28				adc 	ZLTemp1+2
.a4e3	95 12		sta $12,x			sta 	A_Mantissa+2,x
.a4e5	b5 13		lda $13,x			lda 	A_Mantissa+3,x
.a4e7	65 29		adc $29				adc 	ZLTemp1+3
.a4e9	95 13		sta $13,x			sta 	A_Mantissa+3,x
.a4eb	90 0a		bcc $a4f7			bcc 	_FPUTimes10
.a4ed	76 13		ror $13,x			ror 	3+A_Mantissa,x
.a4ef	76 12		ror $12,x			ror 	2+A_Mantissa,x
.a4f1	76 11		ror $11,x			ror 	1+A_Mantissa,x
.a4f3	76 10		ror $10,x			ror 	0+A_Mantissa,x
.a4f5	f6 14		inc $14,x			inc 	A_Exponent,x				; fix exponent
.a4f7					_FPUTimes10:
.a4f7	b5 14		lda $14,x			lda 	A_Exponent,x 				; fix up x 2^3
.a4f9	18		clc				clc
.a4fa	69 03		adc #$03			adc 	#3
.a4fc	95 14		sta $14,x			sta 	A_Exponent,x
.a4fe	70 97		bvs $a497			bvs 	FP_Overflow 				; error
.a500	60		rts				rts
.a501					FPUNormaliseX:
.a501	48		pha				pha
.a502	b5 16		lda $16,x			lda 	A_Zero,x 					; if float-zero, don't need to normalise it.
.a504	d0 16		bne $a51c			bne 	_FPUNExit
.a506					_FPULoop:
.a506	b5 13		lda $13,x			lda 	A_Mantissa+3,x 				; bit 31 of mantissa set.
.a508	30 12		bmi $a51c			bmi 	_FPUNExit 					; if so, we are normalised.
.a50a	16 10		asl $10,x			asl 	0+A_Mantissa+0,x
.a50c	36 11		rol $11,x			rol 	1+A_Mantissa+0,x
.a50e	36 12		rol $12,x			rol 	2+A_Mantissa+0,x
.a510	36 13		rol $13,x			rol 	3+A_Mantissa+0,x
.a512	d6 14		dec $14,x			dec 	A_Exponent,x 				; decrement exponent
.a514	b5 14		lda $14,x			lda 	A_Exponent,x 				; if exponent not $7F (e.g. gone < -$80)
.a516	c9 7f		cmp #$7f			cmp 	#$7F
.a518	d0 ec		bne $a506			bne 	_FPULoop
.a51a	d6 16		dec $16,x			dec 	A_Zero,x 					; the result is now zero.
.a51c					_FPUNExit:
.a51c	68		pla				pla
.a51d	60		rts				rts
.a51e					FPUIntegerNegateX:
.a51e	48		pha				pha
.a51f	38		sec				sec
.a520	a9 00		lda #$00			lda 	#0
.a522	f5 10		sbc $10,x			sbc 	A_Mantissa+0,x
.a524	95 10		sta $10,x			sta 	A_Mantissa+0,x
.a526	a9 00		lda #$00			lda 	#0
.a528	f5 11		sbc $11,x			sbc 	A_Mantissa+1,x
.a52a	95 11		sta $11,x			sta 	A_Mantissa+1,x
.a52c	a9 00		lda #$00			lda 	#0
.a52e	f5 12		sbc $12,x			sbc 	A_Mantissa+2,x
.a530	95 12		sta $12,x			sta 	A_Mantissa+2,x
.a532	a9 00		lda #$00			lda 	#0
.a534	f5 13		sbc $13,x			sbc 	A_Mantissa+3,x
.a536	95 13		sta $13,x			sta 	A_Mantissa+3,X
.a538	68		pla				pla
.a539	60		rts				rts
.a53a					FPCompare:
.a53a	a5 14		lda $14				lda 	A_Exponent 					; save the exponents on the stack
.a53c	48		pha				pha
.a53d	a5 1c		lda $1c				lda 	B_Exponent
.a53f	48		pha				pha
.a540	20 7e a5	jsr $a57e			jsr 	FPSubtract 					; calculate A-B
.a543	a5 16		lda $16				lda 	A_Zero 						; is the result zero ?
.a545	d0 32		bne $a579			bne 	_FPCPullZero 				; if so, then return zero throwing saved exp
.a547	68		pla				pla
.a548	85 18		sta $18				sta 	B_Mantissa 					; BM+0 is BX
.a54a	68		pla				pla
.a54b	85 19		sta $19				sta 	B_Mantissa+1 				; BM+1 is AX
.a54d	38		sec				sec
.a54e	e5 18		sbc $18				sbc 	B_Mantissa 					; AX-BX
.a550	70 1f		bvs $a571			bvs 	_FPCNotEqual				; overflow, can't be equal.
.a552	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.a553	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.a555	b0 1a		bcs $a571			bcs 	_FPCNotEqual
.a557	18		clc				clc
.a558	a5 18		lda $18				lda 	B_Mantissa 					; mean of exponents
.a55a	65 19		adc $19				adc 	B_Mantissa+1
.a55c	6a		ror a				ror 	a 							; shift carry out back in.
.a55d	38		sec				sec
.a55e	e9 0c		sbc #$0c			sbc 	#12 						; allow for 2^12 error, relatively, about 4 DP ish.
.a560	50 02		bvc $a564			bvc 	_FPCNotRange 				; keep in range.
.a562	a9 80		lda #$80			lda 	#$80
.a564					_FPCNotRange:
.a564	38		sec				sec
.a565	e5 14		sbc $14				sbc 	A_Exponent  				; if exponent of difference more than this.
.a567	50 02		bvc $a56b			bvc 	_FPCNotOverflow 			; signed comparison
.a569	49 80		eor #$80			eor 	#$80
.a56b					_FPCNotOverflow:
.a56b	30 04		bmi $a571			bmi 	_FPCNotEqual 				; then error is too large, so return -1 or 1
.a56d	a9 00		lda #$00			lda 	#0 							; "approximately equal" allowing for rounding
.a56f	80 0c		bra $a57d			bra 	_FPCExit 					; errors.
.a571					_FPCNotEqual:
.a571	a5 15		lda $15				lda 	A_Sign 						; if sign is -ve , will be $FF, so return $FF
.a573	d0 08		bne $a57d			bne 	_FPCExit
.a575	a9 01		lda #$01			lda 	#1 							; otherwise return $01 as not zero.
.a577	80 04		bra $a57d			bra 	_FPCExit
.a579					_FPCPullZero:
.a579	68		pla				pla 								; throw saved exponents
.a57a	68		pla				pla
.a57b	a9 00		lda #$00			lda 	#0 							; and return zero
.a57d					_FPCExit:
.a57d	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: arithmetic/fpadd.asm

.a57e					FPSubtract:
.a57e	48		pha				pha
.a57f	a5 1d		lda $1d				lda 	B_Sign 						; flip the sign of B and add
.a581	49 ff		eor #$ff			eor 	#$FF
.a583	85 1d		sta $1d				sta 	B_Sign
.a585	68		pla				pla
.a586					FPAdd:
.a586	48		pha				pha
.a587	da		phx				phx
.a588	a5 15		lda $15				lda 	A_Sign 						; if A is -ve, specialised code
.a58a	d0 06		bne $a592			bne 	_FPA_NegativeLHS
.a58c	20 aa a5	jsr $a5aa			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.a58f	fa		plx				plx
.a590	68		pla				pla
.a591	60		rts				rts
.a592					_FPA_NegativeLHS:
.a592	a5 15		lda $15				lda 	A_Sign 						; flip A and B signs
.a594	49 ff		eor #$ff			eor 	#$FF
.a596	85 15		sta $15				sta 	A_Sign
.a598	a5 1d		lda $1d				lda 	B_Sign
.a59a	49 ff		eor #$ff			eor 	#$FF
.a59c	85 1d		sta $1d				sta 	B_Sign 						; so now it's A +- B
.a59e	20 aa a5	jsr $a5aa			jsr 	FPAdd_Worker
.a5a1	a5 15		lda $15				lda 	A_Sign 						; and flip the result sign
.a5a3	49 ff		eor #$ff			eor 	#$FF
.a5a5	85 15		sta $15				sta 	A_Sign
.a5a7	fa		plx				plx
.a5a8	68		pla				pla
.a5a9	60		rts				rts
.a5aa					FPAdd_Worker:
.a5aa	a5 1e		lda $1e				lda 	B_Zero 						; if B is zero (e.g. adding zero)
.a5ac	d0 78		bne $a626			bne 	_FPAWExit 					; no change.
.a5ae	a5 16		lda $16				lda 	A_Zero 						; if A is zero (e.g. 0 + B)
.a5b0	d0 71		bne $a623			bne 	_FPAWReturnB 				; then return B.
.a5b2					_FPAWMakeSame:
.a5b2	a2 00		ldx #$00			ldx 	#0 							; shift offset, this is to shift A.
.a5b4	a5 14		lda $14				lda 	A_Exponent 					; check if exponents are the same.
.a5b6	38		sec				sec
.a5b7	e5 1c		sbc $1c				sbc	 	B_Exponent
.a5b9	f0 14		beq $a5cf			beq 	_FPAW_DoArithmetic 			; if they are,
.a5bb	50 02		bvc $a5bf			bvc 	_FPAWNoOverflow 			; make it a signed comparison.
.a5bd	49 80		eor #$80			eor 	#$80
.a5bf					_FPAWNoOverflow:
.a5bf	30 02		bmi $a5c3			bmi 	_FPAWShiftA 				; if eA < eB then shift A
.a5c1	a2 08		ldx #$08			ldx 	#B_Mantissa-A_Mantissa 		; if eA > eB then shift B
.a5c3					_FPAWShiftA:
.a5c3	f6 14		inc $14,x			inc 	A_Exponent,x 				; so shift exponent up.
.a5c5	56 13		lsr $13,x			lsr 	3+A_Mantissa,x
.a5c7	76 12		ror $12,x			ror 	2+A_Mantissa,x
.a5c9	76 11		ror $11,x			ror 	1+A_Mantissa,x
.a5cb	76 10		ror $10,x			ror 	0+A_Mantissa,x
.a5cd	80 e3		bra $a5b2			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.a5cf					_FPAW_DoArithmetic:
.a5cf	a5 1d		lda $1d				lda 	B_Sign 						; is it adding a negative to a positive
.a5d1	d0 28		bne $a5fb			bne 	_FPAW_BNegative
.a5d3	18		clc				clc
.a5d4	a5 10		lda $10				lda 	A_Mantissa+0
.a5d6	65 18		adc $18				adc 	B_Mantissa+0
.a5d8	85 10		sta $10				sta 	A_Mantissa+0
.a5da	a5 11		lda $11				lda 	A_Mantissa+1
.a5dc	65 19		adc $19				adc 	B_Mantissa+1
.a5de	85 11		sta $11				sta 	A_Mantissa+1
.a5e0	a5 12		lda $12				lda 	A_Mantissa+2
.a5e2	65 1a		adc $1a				adc 	B_Mantissa+2
.a5e4	85 12		sta $12				sta 	A_Mantissa+2
.a5e6	a5 13		lda $13				lda 	A_Mantissa+3
.a5e8	65 1b		adc $1b				adc 	B_Mantissa+3
.a5ea	85 13		sta $13				sta 	A_Mantissa+3
.a5ec	90 38		bcc $a626			bcc 	_FPAWExit 					; no carry.
.a5ee	e6 14		inc $14				inc 	A_Exponent 					; so shift exponent up.
.a5f0	38		sec				sec
.a5f1	66 13		ror $13				ror 	3+A_Mantissa
.a5f3	66 12		ror $12				ror 	2+A_Mantissa
.a5f5	66 11		ror $11				ror 	1+A_Mantissa
.a5f7	66 10		ror $10				ror 	0+A_Mantissa
.a5f9	80 2b		bra $a626			bra 	_FPAWExit
.a5fb					_FPAW_BNegative:
.a5fb	38		sec				sec
.a5fc	a5 10		lda $10				lda 	A_Mantissa+0
.a5fe	e5 18		sbc $18				sbc 	B_Mantissa+0
.a600	85 10		sta $10				sta 	A_Mantissa+0
.a602	a5 11		lda $11				lda 	A_Mantissa+1
.a604	e5 19		sbc $19				sbc 	B_Mantissa+1
.a606	85 11		sta $11				sta 	A_Mantissa+1
.a608	a5 12		lda $12				lda 	A_Mantissa+2
.a60a	e5 1a		sbc $1a				sbc 	B_Mantissa+2
.a60c	85 12		sta $12				sta 	A_Mantissa+2
.a60e	a5 13		lda $13				lda 	A_Mantissa+3
.a610	e5 1b		sbc $1b				sbc 	B_Mantissa+3
.a612	85 13		sta $13				sta 	A_Mantissa+3
.a614	b0 10		bcs $a626			bcs		_FPAWExit 					; no borrow.
.a616	a2 00		ldx #$00			ldx 	#0  						; negate the mantissa
.a618	20 1e a5	jsr $a51e			jsr 	FPUIntegerNegateX
.a61b	a5 15		lda $15				lda 	A_Sign 						; flip result sign
.a61d	49 ff		eor #$ff			eor 	#$FF
.a61f	85 15		sta $15				sta 	A_Sign
.a621	80 03		bra $a626			bra 	_FPAWExit
.a623					_FPAWReturnB:
.a623	20 1c a4	jsr $a41c			jsr 	FPUCopyBToA 				; copy B into A
.a626					_FPAWExit:
.a626	a2 00		ldx #$00			ldx 	#0 							; normalise A
.a628	20 01 a5	jsr $a501			jsr 	FPUNormaliseX
.a62b	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: arithmetic/fpmultiply.asm

.a62c					FPMultiply:
.a62c	48		pha				pha
.a62d	da		phx				phx
.a62e	a5 1e		lda $1e				lda		B_Zero 						; if B = 0, return B unchanged
.a630	d0 6e		bne $a6a0			bne 	_FPM_ReturnB
.a632	a5 16		lda $16				lda 	A_Zero 						; if A = 0, return A
.a634	d0 6d		bne $a6a3			bne 	_FPM_Exit
.a636	a5 14		lda $14				lda 	A_Exponent					; add their exponents
.a638	18		clc				clc
.a639	65 1c		adc $1c				adc 	B_Exponent
.a63b	85 14		sta $14				sta 	A_Exponent 					; exponent of result.
.a63d	10 05		bpl $a644			bpl 	_FPM_NoOverflow 			; error if -ve result and overflow.
.a63f	50 03		bvc $a644			bvc 	_FPM_NoOverflow
.a641	4c 97 a4	jmp $a497			jmp 	FP_Overflow
.a644					_FPM_NoOverflow:
.a644	a9 00		lda #$00			lda 	#0
.a646	85 26		sta $26				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.a648	85 27		sta $27				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.a64a	85 28		sta $28				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.a64c	85 29		sta $29				sta 	zLTemp1+3
.a64e	a2 20		ldx #$20			ldx 	#32							; X is loop counter
.a650					_FPM_Loop:
.a650	a5 10		lda $10				lda 	A_Mantissa					; check LSB of long product
.a652	29 01		and #$01			and 	#1
.a654	18		clc				clc 								; clear carry for the long rotate.
.a655	f0 19		beq $a670			beq 	_FPM_NoAddition
.a657	18		clc				clc
.a658	a5 26		lda $26				lda 	zLTemp1+0
.a65a	65 18		adc $18				adc 	B_Mantissa+0
.a65c	85 26		sta $26				sta 	zLTemp1+0
.a65e	a5 27		lda $27				lda 	zLTemp1+1
.a660	65 19		adc $19				adc 	B_Mantissa+1
.a662	85 27		sta $27				sta 	zLTemp1+1
.a664	a5 28		lda $28				lda 	zLTemp1+2
.a666	65 1a		adc $1a				adc 	B_Mantissa+2
.a668	85 28		sta $28				sta 	zLTemp1+2
.a66a	a5 29		lda $29				lda 	zLTemp1+3
.a66c	65 1b		adc $1b				adc 	B_Mantissa+3
.a66e	85 29		sta $29				sta 	zLTemp1+3
.a670					_FPM_NoAddition:
.a670	66 29		ror $29				ror 	3+zLTemp1
.a672	66 28		ror $28				ror 	2+zLTemp1
.a674	66 27		ror $27				ror 	1+zLTemp1
.a676	66 26		ror $26				ror 	0+zLTemp1
.a678	66 13		ror $13				ror 	3+A_Mantissa
.a67a	66 12		ror $12				ror 	2+A_Mantissa
.a67c	66 11		ror $11				ror 	1+A_Mantissa
.a67e	66 10		ror $10				ror 	0+A_Mantissa
.a680	ca		dex				dex
.a681	d0 cd		bne $a650			bne 	_FPM_Loop 					; do this 32 times.
.a683	a5 26		lda $26				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.a685	85 10		sta $10				sta 	A_Mantissa+0
.a687	a5 27		lda $27				lda 	zLTemp1+1
.a689	85 11		sta $11				sta 	A_Mantissa+1
.a68b	a5 28		lda $28				lda 	zLTemp1+2
.a68d	85 12		sta $12				sta 	A_Mantissa+2
.a68f	a5 29		lda $29				lda 	zLTemp1+3
.a691	85 13		sta $13				sta 	A_Mantissa+3
.a693	a5 15		lda $15				lda 	A_Sign 						; sign is xor of signs
.a695	45 1d		eor $1d				eor 	B_Sign
.a697	85 15		sta $15				sta 	A_Sign
.a699	a2 00		ldx #$00			ldx 	#0 							; normalise the result
.a69b	20 01 a5	jsr $a501			jsr 	FPUNormaliseX
.a69e	80 03		bra $a6a3			bra		_FPM_Exit
.a6a0					_FPM_ReturnB:
.a6a0	20 1c a4	jsr $a41c			jsr 	FPUCopyBToA
.a6a3					_FPM_Exit:
.a6a3	fa		plx				plx
.a6a4	68		pla				pla
.a6a5	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: arithmetic/fpdivide.asm

.a6a6					FPD_IsDivZero:
.a6a6	20 5a a9	jsr $a95a			jsr 		ERR_Handler
>a6a9	44 69 76 69 73 69 6f 6e				.text 		"Division by zero",0
>a6b1	20 62 79 20 7a 65 72 6f 00
.a6ba					FPDivide:
.a6ba	48		pha				pha
.a6bb	da		phx				phx
.a6bc	a5 1e		lda $1e				lda 	B_Zero 						; check if division by zero
.a6be	d0 e6		bne $a6a6			bne 	FPD_IsDivZero
.a6c0	a5 16		lda $16				lda 	A_Zero 						; if 0/X (X is not zero) return 0
.a6c2	d0 7d		bne $a741			bne 	_FPD_Exit
.a6c4	a5 14		lda $14				lda 	A_Exponent 					; calculate new exponent
.a6c6	38		sec				sec
.a6c7	e5 1c		sbc $1c				sbc 	B_Exponent
.a6c9	10 05		bpl $a6d0			bpl 	_FPD_NoOverflow 			; check for overflow.
.a6cb	50 03		bvc $a6d0			bvc 	_FPD_NoOverflow
.a6cd					_FPD_Overflow:
.a6cd	4c 97 a4	jmp $a497			jmp 	FP_Overflow
.a6d0					_FPD_NoOverflow:
.a6d0	18		clc				clc 	 							; x 2, overflow if -ve
.a6d1	69 01		adc #$01			adc 	#1
.a6d3	70 f8		bvs $a6cd			bvs 	_FPD_Overflow
.a6d5	85 14		sta $14				sta 	A_Exponent
.a6d7	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.a6d9	85 26		sta $26				sta 	zLTemp1+0
.a6db	85 27		sta $27				sta 	zLTemp1+1
.a6dd	85 28		sta $28				sta 	zLTemp1+2
.a6df	85 29		sta $29				sta 	zLTemp1+3
.a6e1	a2 20		ldx #$20			ldx 	#32 						; times round.
.a6e3					_FPD_Loop:
.a6e3	38		sec				sec 								; calculate A-B stacking result.
.a6e4	a5 10		lda $10				lda 	A_Mantissa+0
.a6e6	e5 18		sbc $18				sbc 	B_Mantissa+0
.a6e8	48		pha				pha
.a6e9	a5 11		lda $11				lda 	A_Mantissa+1
.a6eb	e5 19		sbc $19				sbc 	B_Mantissa+1
.a6ed	48		pha				pha
.a6ee	a5 12		lda $12				lda 	A_Mantissa+2
.a6f0	e5 1a		sbc $1a				sbc 	B_Mantissa+2
.a6f2	48		pha				pha
.a6f3	a5 13		lda $13				lda 	A_Mantissa+3
.a6f5	e5 1b		sbc $1b				sbc 	B_Mantissa+3
.a6f7	90 13		bcc $a70c			bcc		_FPD_NoSubtract 			; if CC couldn't subtract
.a6f9	85 13		sta $13				sta 	A_Mantissa+3 				; save results out to A
.a6fb	68		pla				pla
.a6fc	85 12		sta $12				sta 	A_Mantissa+2
.a6fe	68		pla				pla
.a6ff	85 11		sta $11				sta 	A_Mantissa+1
.a701	68		pla				pla
.a702	85 10		sta $10				sta 	A_Mantissa+0
.a704	a5 29		lda $29				lda 	zLTemp1+3 					; set high bit of result
.a706	09 80		ora #$80			ora 	#$80
.a708	85 29		sta $29				sta 	zLTemp1+3
.a70a	80 03		bra $a70f			bra 	_FPD_Rotates
.a70c					_FPD_NoSubtract:
.a70c	68		pla				pla 								; throw away unwanted results
.a70d	68		pla				pla
.a70e	68		pla				pla
.a70f					_FPD_Rotates:
.a70f	46 1b		lsr $1b				lsr 	3+B_Mantissa
.a711	66 1a		ror $1a				ror 	2+B_Mantissa
.a713	66 19		ror $19				ror 	1+B_Mantissa
.a715	66 18		ror $18				ror 	0+B_Mantissa
.a717	06 26		asl $26				asl 	0+zLTemp1
.a719	26 27		rol $27				rol 	1+zLTemp1
.a71b	26 28		rol $28				rol 	2+zLTemp1
.a71d	26 29		rol $29				rol 	3+zLTemp1
.a71f	90 02		bcc $a723			bcc 	_FPD_NoCarry
.a721	e6 26		inc $26				inc 	zLTemp1 					; if rotated out, set LSB.
.a723					_FPD_NoCarry:
.a723	ca		dex				dex 								; do 32 times
.a724	d0 bd		bne $a6e3			bne 	_FPD_Loop
.a726	a5 26		lda $26				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.a728	85 10		sta $10				sta 	A_Mantissa+0
.a72a	a5 27		lda $27				lda 	zLTemp1+1
.a72c	85 11		sta $11				sta 	A_Mantissa+1
.a72e	a5 28		lda $28				lda 	zLTemp1+2
.a730	85 12		sta $12				sta 	A_Mantissa+2
.a732	a5 29		lda $29				lda 	zLTemp1+3
.a734	85 13		sta $13				sta 	A_Mantissa+3
.a736	a5 15		lda $15				lda 	A_Sign 						; sign is xor of signs
.a738	45 1d		eor $1d				eor 	B_Sign
.a73a	85 15		sta $15				sta 	A_Sign
.a73c	a2 00		ldx #$00			ldx 	#0 							; normalise the result
.a73e	20 01 a5	jsr $a501			jsr 	FPUNormaliseX
.a741					_FPD_Exit:
.a741	fa		plx				plx
.a742	68		pla				pla
.a743	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: arithmetic/fpparts.asm

.a744					FPFractionalPart:
.a744	a5 14		lda $14				lda 	A_Exponent 					; if exponent -ve then then unchanged
.a746	38		sec				sec 								; this flag tells us to keep the fractional part
.a747	10 0d		bpl $a756			bpl 	FPGetPart
.a749	60		rts				rts
.a74a					FPIntegerPart:
.a74a	a5 14		lda $14				lda 	A_Exponent 					; if exponent -ve then the result is zero.
.a74c	18		clc				clc 								; this flag says keep the integer part.
.a74d	10 07		bpl $a756			bpl 	FPGetPart
.a74f	48		pha				pha
.a750	a9 ff		lda #$ff			lda 	#$FF 						; set the Zero Flag
.a752	85 16		sta $16				sta 	A_Zero
.a754	68		pla				pla
.a755	60		rts				rts
.a756					FPGetPart:
.a756	48		pha				pha
.a757	da		phx				phx 								; save X
.a758	a5 16		lda $16				lda 	A_Zero 						; if zero, return zero
.a75a	d0 4d		bne $a7a9			bne 	_FPGP_Exit 					; then do nothing.
.a75c	08		php				php 								; save the action flag on the stack.
.a75d	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.a75f	85 26		sta $26				sta 	zLTemp1+0
.a761	85 27		sta $27				sta 	zLTemp1+1
.a763	85 28		sta $28				sta 	zLTemp1+2
.a765	85 29		sta $29				sta 	zLTemp1+3
.a767	a6 14		ldx $14				ldx 	A_Exponent 					; the number of shifts.
.a769	f0 11		beq $a77c			beq 	_FPGP_NoShift 				; ... if any
.a76b	e0 20		cpx #$20			cpx 	#32
.a76d	90 02		bcc $a771			bcc 	_FPGP_NotMax
.a76f	a2 20		ldx #$20			ldx 	#32 						; max of 32.
.a771					_FPGP_NotMax:
.a771	46 29		lsr $29				lsr 	3+zLTemp1
.a773	66 28		ror $28				ror 	2+zLTemp1
.a775	66 27		ror $27				ror 	1+zLTemp1
.a777	66 26		ror $26				ror 	0+zLTemp1
.a779	ca		dex				dex
.a77a	d0 f5		bne $a771			bne 	_FPGP_NotMax
.a77c					_FPGP_NoShift:
.a77c	a2 03		ldx #$03			ldx 	#3 							; now mask each part in turn.
.a77e					_FPGP_MaskLoop:
.a77e	b5 26		lda $26,x			lda 	zlTemp1,x 					; get mask.
.a780	28		plp				plp 								; if CC we keep the top part, so we
.a781	08		php				php		 							; flip the mask.
.a782	b0 02		bcs $a786			bcs		_FPGP_NoFlip
.a784	49 ff		eor #$ff			eor 	#$FF
.a786					_FPGP_NoFlip:
.a786	35 10		and $10,x			and 	A_Mantissa,x
.a788	95 10		sta $10,x			sta 	A_Mantissa,x
.a78a	ca		dex				dex
.a78b	10 f1		bpl $a77e			bpl 	_FPGP_MaskLoop
.a78d	28		plp				plp 								; get action flag on the stack
.a78e	90 04		bcc $a794			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.a790	a9 00		lda #$00			lda 	#0
.a792	85 15		sta $15				sta 	A_Sign
.a794					_FPGP_NotFractional:
.a794	a5 10		lda $10				lda 	A_Mantissa 							; check if \1 zero
.a796	05 11		ora $11				ora 	A_Mantissa+1
.a798	05 12		ora $12				ora 	A_Mantissa+2
.a79a	05 13		ora $13				ora 	A_Mantissa+3
.a79c	f0 07		beq $a7a5			beq 	_FPGP_Zero 					; if zero, return zero
.a79e	a2 00		ldx #$00			ldx 	#0							; otherwise normalise
.a7a0	20 01 a5	jsr $a501			jsr 	FPUNormaliseX
.a7a3	80 04		bra $a7a9			bra 	_FPGP_Exit 					; and exit
.a7a5					_FPGP_Zero:
.a7a5	a9 ff		lda #$ff			lda 	#$FF 						; set zero flag
.a7a7	85 16		sta $16				sta 	A_Zero
.a7a9					_FPGP_Exit:
.a7a9	fa		plx				plx
.a7aa	68		pla				pla
.a7ab	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: arithmetic/inttostr.asm

.a7ac					INTToString:
.a7ac	48		pha				pha
.a7ad	da		phx				phx
.a7ae	5a		phy				phy
.a7af	a5 13		lda $13				lda 		A_Mantissa+3 			; check -ve
.a7b1	10 0a		bpl $a7bd			bpl 		_ITSNotMinus
.a7b3	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.a7b5	20 38 a8	jsr $a838			jsr 		ITSOutputCharacter
.a7b8	a2 00		ldx #$00			ldx 		#0
.a7ba	20 1e a5	jsr $a51e			jsr 		FPUIntegerNegateX
.a7bd					_ITSNotMinus:
.a7bd	a2 00		ldx #$00			ldx 		#0 						; X is offset in table.
.a7bf	8e 21 03	stx $0321			stx 		NumSuppress 			; clear the suppression flag.
.a7c2					_ITSNextSubtractor:
.a7c2	a0 00		ldy #$00			ldy 		#0 						; Y is count.
.a7c4					_ITSSubtract:
.a7c4	38		sec				sec
.a7c5	a5 10		lda $10				lda 		A_Mantissa 				; subtract number and push on stack
.a7c7	fd 14 a8	sbc $a814,x			sbc 		_ITSSubtractors+0,x
.a7ca	48		pha				pha
.a7cb	a5 11		lda $11				lda 		A_Mantissa+1
.a7cd	fd 15 a8	sbc $a815,x			sbc 		_ITSSubtractors+1,x
.a7d0	48		pha				pha
.a7d1	a5 12		lda $12				lda 		A_Mantissa+2
.a7d3	fd 16 a8	sbc $a816,x			sbc 		_ITSSubtractors+2,x
.a7d6	48		pha				pha
.a7d7	a5 13		lda $13				lda 		A_Mantissa+3
.a7d9	fd 17 a8	sbc $a817,x			sbc 		_ITSSubtractors+3,x
.a7dc	90 0e		bcc $a7ec			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.a7de	85 13		sta $13				sta 		A_Mantissa+3 			; save subtract off stack
.a7e0	68		pla				pla
.a7e1	85 12		sta $12				sta 		A_Mantissa+2
.a7e3	68		pla				pla
.a7e4	85 11		sta $11				sta 		A_Mantissa+1
.a7e6	68		pla				pla
.a7e7	85 10		sta $10				sta 		A_Mantissa+0
.a7e9	c8		iny				iny 								; bump count.
.a7ea	80 d8		bra $a7c4			bra 		_ITSSubtract 			; go round again.
.a7ec					_ITSCantSubtract:
.a7ec	68		pla				pla 								; throw away interim answers
.a7ed	68		pla				pla
.a7ee	68		pla				pla
.a7ef	c0 00		cpy #$00			cpy 		#0 						; if not zero then no suppression check
.a7f1	d0 05		bne $a7f8			bne 		_ITSOutputDigit
.a7f3	2c 21 03	bit $0321			bit 		NumSuppress 			; if suppression check +ve (e.g. zero)
.a7f6	10 09		bpl $a801			bpl 		_ITSGoNextSubtractor
.a7f8					_ITSOutputDigit:
.a7f8	ce 21 03	dec $0321			dec 		NumSuppress 			; suppression check will be -ve.
.a7fb	98		tya				tya 								; count of subtractions
.a7fc	09 30		ora #$30			ora 		#"0"					; make ASCII
.a7fe	20 38 a8	jsr $a838			jsr 		ITSOutputCharacter 		; output it.
.a801					_ITSGoNextSubtractor:
.a801	e8		inx				inx 								; next dword
.a802	e8		inx				inx
.a803	e8		inx				inx
.a804	e8		inx				inx
.a805	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.a807	d0 b9		bne $a7c2			bne 		_ITSNextSubtractor 		; do all the subtractors.
.a809	a5 10		lda $10				lda 		A_Mantissa 				; and the last digit is left.
.a80b	09 30		ora #$30			ora 		#"0"
.a80d	20 38 a8	jsr $a838			jsr 		ITSOutputCharacter
.a810	7a		ply				ply 								; and exit
.a811	fa		plx				plx
.a812	68		pla				pla
.a813	60		rts				rts
.a814					_ITSSubtractors:
>a814	00 ca 9a 3b					.dword 		1000000000
>a818	00 e1 f5 05					.dword 		100000000
>a81c	80 96 98 00					.dword 		10000000
>a820	40 42 0f 00					.dword 		1000000
>a824	a0 86 01 00					.dword 		100000
>a828	10 27 00 00					.dword 		10000
>a82c	e8 03 00 00					.dword 		1000
>a830	64 00 00 00					.dword 		100
>a834	0a 00 00 00					.dword 		10
.a838					_ITSSubtractorsEnd:
.a838					ITSOutputCharacter:
.a838	48		pha				pha
.a839	da		phx				phx
.a83a	ae 20 03	ldx $0320			ldx 	NumBufX 					; save digit
.a83d	9d 00 03	sta $0300,x			sta 	Num_Buffer,x
.a840	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.a842	9d 01 03	sta $0301,x			sta 	Num_Buffer+1,x
.a845	ee 20 03	inc $0320			inc 	NumBufX						; bump pointer.
.a848	fa		plx				plx
.a849	68		pla				pla
.a84a	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: arithmetic/fptostr.asm

.a84b					FPToString:
.a84b	48		pha				pha
.a84c	da		phx				phx
.a84d	5a		phy				phy
.a84e	a9 00		lda #$00			lda 		#0	 					; reset the index.
.a850	8d 20 03	sta $0320			sta 		NumBufX
.a853	a5 17		lda $17				lda 		A_Type
.a855	d0 0e		bne $a865			bne 		_FPTSIsFloat 			; if zero, go to floating point code.
.a857	20 ac a7	jsr $a7ac			jsr 		INTToString 			; convert it as a simple int, it's an integer.
.a85a					_FPTSExit:
.a85a	7a		ply				ply
.a85b	fa		plx				plx
.a85c	68		pla				pla
.a85d	60		rts				rts
.a85e					_FPTSZero:
.a85e	a9 30		lda #$30			lda 		#"0"
.a860	20 38 a8	jsr $a838			jsr 		ITSOutputCharacter
.a863	80 f5		bra $a85a			bra 		_FPTSExit
.a865					_FPTSIsFloat:
.a865	a5 16		lda $16				lda 		A_Zero 					; is it zero ?
.a867	d0 f5		bne $a85e			bne 		_FPTSZero 				; output a zero ?
.a869	a5 15		lda $15				lda 		A_Sign 					; is it signed ?
.a86b	f0 09		beq $a876			beq 		_FPTSNotSigned
.a86d	a9 00		lda #$00			lda 		#0 						; clear sign flag
.a86f	85 15		sta $15				sta 		A_Sign
.a871	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.a873	20 38 a8	jsr $a838			jsr 		ITSOutputCharacter
.a876					_FPTSNotSigned:
.a876	20 7b a8	jsr $a87b			jsr 		FPTOutputBody 			; output the body.
.a879	80 df		bra $a85a			bra 		_FPTSExit
.a87b					FPTOutputBody:
.a87b	20 0e a4	jsr $a40e			jsr 		FPUCopyAtoB 			; save in B
.a87e	a2 00		ldx #$00			ldx 		#0
.a880	20 57 a4	jsr $a457			jsr 		FPUAToInteger 			; convert A to integer
.a883	20 ac a7	jsr $a7ac			jsr 		INTToString  			; output integer part as string.
.a886	20 1c a4	jsr $a41c			jsr 		FPUCopyBToA 			; get back.
.a889	20 44 a7	jsr $a744			jsr 		FPFractionalPart 		; get the fractional part.
.a88c	a5 16		lda $16				lda 		A_Zero 					; any fractional part ?
.a88e	d0 40		bne $a8d0			bne 		_FPTOExit 				; exit if so.
.a890	a9 2e		lda #$2e			lda 		#"."					; output a decimal place
.a892	20 38 a8	jsr $a838			jsr 		ITSOutputCharacter
.a895					_FPDecimalLoop:
.a895	a5 16		lda $16				lda 		A_Zero 					; zeroed out A
.a897	d0 21		bne $a8ba			bne 		_FPTOExit2
.a899	ad 20 03	lda $0320			lda 		NumBufX 				; too many characters out.
.a89c	c9 0b		cmp #$0b			cmp			#11
.a89e	b0 1a		bcs $a8ba			bcs 		_FPToExit2
.a8a0	a2 00		ldx #$00			ldx 		#0						; multiply A by 10
.a8a2	20 b2 a4	jsr $a4b2			jsr 		FPUTimes10X
.a8a5	20 0e a4	jsr $a40e			jsr 		FPUCopyAToB 			; copy to B
.a8a8	20 57 a4	jsr $a457			jsr 		FPUAToInteger 			; make integer
.a8ab	a5 10		lda $10				lda 		A_Mantissa 				; output digit
.a8ad	09 30		ora #$30			ora 		#"0"
.a8af	20 38 a8	jsr $a838			jsr 		ITSOutputCharacter
.a8b2	20 1c a4	jsr $a41c			jsr 		FPUCopyBToA 			; get it back.
.a8b5	20 44 a7	jsr $a744			jsr 		FPFractionalPart 		; get fractional part
.a8b8	80 db		bra $a895			bra 		_FPDecimalLoop
.a8ba					_FPTOExit2:
.a8ba	ae 20 03	ldx $0320			ldx 		NumBufX 				; strip trailing DPs.
.a8bd					_FPStrip:
.a8bd	ca		dex				dex 								; back one.
.a8be	30 10		bmi $a8d0			bmi 		_FPToExit 				; too far
.a8c0	bd 00 03	lda $0300,x			lda 		Num_Buffer,x 			; 0 ?
.a8c3	c9 30		cmp #$30			cmp 		#"0"
.a8c5	f0 f6		beq $a8bd			beq 		_FPStrip
.a8c7	e8		inx				inx 								; first zero.
.a8c8	8e 20 03	stx $0320			stx 		NumBufX 				; save position
.a8cb	a9 00		lda #$00			lda 		#0 						; trim
.a8cd	9d 00 03	sta $0300,x			sta 		Num_Buffer,X
.a8d0					_FPTOExit:
.a8d0	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: arithmetic/intfromstr.asm

.a8d1					IntFromString:
.a8d1	5a		phy				phy
.a8d2	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.a8d4	85 10		sta $10				sta 	A_Mantissa
.a8d6	85 11		sta $11				sta 	A_Mantissa+1
.a8d8	85 12		sta $12				sta 	A_Mantissa+2
.a8da	85 13		sta $13				sta 	A_Mantissa+3
.a8dc	a8		tay				tay 								; character index.
.a8dd					_IFSLoop:
.a8dd	b1 2a		lda ($2a),y			lda 	(zGenPtr),y 				; get next
.a8df	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.a8e1	90 45		bcc $a928			bcc 	_IFSExit
.a8e3	c9 3a		cmp #$3a			cmp 	#"9"+1
.a8e5	b0 41		bcs $a928			bcs 	_IFSExit
.a8e7	a5 13		lda $13				lda 	A_Mantissa+3 				; push mantissa on stack backwards
.a8e9	48		pha				pha
.a8ea	a5 12		lda $12				lda 	A_Mantissa+2
.a8ec	48		pha				pha
.a8ed	a5 11		lda $11				lda 	A_Mantissa+1
.a8ef	48		pha				pha
.a8f0	a5 10		lda $10				lda 	A_Mantissa+0
.a8f2	48		pha				pha
.a8f3	20 2f a9	jsr $a92f			jsr 	IFSAShiftLeft 				; double
.a8f6	20 2f a9	jsr $a92f			jsr 	IFSAShiftLeft 				; x 4
.a8f9	18		clc				clc 								; add saved value x 5
.a8fa	68		pla				pla
.a8fb	65 10		adc $10				adc 	A_Mantissa+0
.a8fd	85 10		sta $10				sta 	A_Mantissa+0
.a8ff	68		pla				pla
.a900	65 11		adc $11				adc 	A_Mantissa+1
.a902	85 11		sta $11				sta 	A_Mantissa+1
.a904	68		pla				pla
.a905	65 12		adc $12				adc 	A_Mantissa+2
.a907	85 12		sta $12				sta 	A_Mantissa+2
.a909	68		pla				pla
.a90a	65 13		adc $13				adc 	A_Mantissa+3
.a90c	85 13		sta $13				sta 	A_Mantissa+3
.a90e	20 2f a9	jsr $a92f			jsr 	IFSAShiftLeft 				; x 10
.a911	b1 2a		lda ($2a),y			lda 	(zGenPtr),y 				; add digit
.a913	29 0f		and #$0f			and 	#15
.a915	c8		iny				iny
.a916	65 10		adc $10				adc 	A_Mantissa
.a918	85 10		sta $10				sta 	A_Mantissa
.a91a	90 c1		bcc $a8dd			bcc 	_IFSLoop
.a91c	e6 11		inc $11				inc 	A_Mantissa+1 				; propogate carry round.
.a91e	d0 bd		bne $a8dd			bne 	_IFSLoop
.a920	e6 12		inc $12				inc 	A_Mantissa+2
.a922	d0 b9		bne $a8dd			bne 	_IFSLoop
.a924	e6 13		inc $13				inc 	A_Mantissa+3
.a926	80 b5		bra $a8dd			bra 	_IFSLoop
.a928					_IFSExit:
.a928	98		tya				tya 								; get offset
.a929	18		clc				clc
.a92a	d0 01		bne $a92d			bne 	_IFSOkay 					; if was non zero, conversion was okay
.a92c	38		sec				sec 								; else no integer found.
.a92d					_IFSOkay:
.a92d	7a		ply				ply 								; and exit.
.a92e	60		rts				rts
.a92f					IFSAShiftLeft:
.a92f	06 10		asl $10				asl 	0+A_Mantissa
.a931	26 11		rol $11				rol 	1+A_Mantissa
.a933	26 12		rol $12				rol 	2+A_Mantissa
.a935	26 13		rol $13				rol 	3+A_Mantissa
.a937	60		rts				rts

;******  Return to file: basic.asm

.a938					StartROM:
.a938	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.a93a	9a		txs				txs
.a93b	20 00 a0	jsr $a000			jsr 		IF_Reset 				; reset external interface
.a93e	20 4a a0	jsr $a04a			jsr 		IFT_ClearScreen
.a941	a9 50		lda #$50			lda 		#toConvert & $FF
.a943	85 2a		sta $2a				sta 		zGenPtr
.a945	a9 a9		lda #$a9			lda 		#toConvert >> 8
.a947	85 2b		sta $2b				sta 		zGenPtr+1
.a949	20 d1 a8	jsr $a8d1			jsr 		INTFromString
.a94c	ea		nop				nop
>a94d	5c						.byte 		$5C
.a94e	80 fe		bra $a94e	h1:		bra 		h1
.a950					toConvert:
>a950	58 33 38 34 32 31 2e 34				.text 		"X38421.45",0
>a958	35 00
.a95a					ERR_Handler:
.a95a	80 fe		bra $a95a			bra 		ERR_Handler
.a95c					NMIHandler:
.a95c	40		rti				rti
>fffa	5c a9						.word		NMIHandler
>fffc	38 a9						.word 		StartROM
>fffe	5d a3						.word 		TIM_BreakVector

;******  End of listing
