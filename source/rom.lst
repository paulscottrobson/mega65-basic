
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -D CPU=6502 -D INTERFACE=1 -b -L rom.lst -o rom.bin basic.asm
; Thu Aug 15 18:04:29 2019

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=6502					CPU=6502
=1					INTERFACE=1

;******  Processing input file: basic.asm

.0000	ea		nop				nop

;******  Processing file: data.asm

>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zLTemp1:	.dword ?						; long word (used in multiply)
>001a					zGenPtr:	.word ? 						; general pointer.
>0300					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0304					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0305					XS_Type 	.byte ? 						; bit 7 sign (float only)
=774					XS2_Mantissa = XS_Mantissa+6
=778					XS2_Exponent = XS_Exponent+6
=779					XS2_Type = XS_Type+6
>0400					Num_Buffer	.fill 	32 						; buffer for numeric conversions
>0420					NumBufX 	.byte 	?						; buffer index position
>0421					NumSuppress	.byte 	?						; leading zero suppression flag
>0422					NumConvCount .byte 	? 						; count for conversions.
>0423					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>0425					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>0427					Tim_SR:		.byte ? 						; Processor Status
>0428					Tim_A:		.byte ? 						; Processor Registers
>0429					Tim_X:		.byte ?
>042a					Tim_Y:		.byte ?
>042b					Tim_Z:		.byte ?
>042c					Tim_SP:		.byte ?							; Stack Pointer
>042d					ExpTemp:	.byte ?							; Working temp for exponents.

;******  Return to file: basic.asm


;******  Processing file: interface/interface_emu.asm

=80					IF_Width 	= 80 							; characters across
=25					IF_Height 	= 25 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=6					IF_XPos 	= 6 							; current position, horizontal.
=$8000					IF_Screen = $8000							; 2k screen RAM here
=$8800					IF_PKeyboard = $8800						; Keyboard port.
=$8801					IF_PBreak = $8801 							; Break key.
.a000					IF_Reset:
.a000	60		rts				rts
.a001					IF_Home:
.a001	48		pha				pha
.a002	a9 00		lda #$00			lda 	#0	 						; zero X position
.a004	85 06		sta $06				sta 	IF_XPos
.a006	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.a008	85 04		sta $04				sta 	IF_Pos
.a00a	a9 80		lda #$80			lda 	#IF_Screen >> 8
.a00c	85 05		sta $05				sta 	IF_Pos+1
.a00e	68		pla				pla
.a00f	60		rts				rts
.a010					IF_NewLine:
.a010	48		pha				pha
.a011	a9 00		lda #$00			lda 	#0 							; back to start of line
.a013	85 06		sta $06				sta 	IF_XPos
.a015	18		clc				clc 								; down one line
.a016	a5 04		lda $04				lda 	IF_Pos
.a018	69 50		adc #$50			adc 	#80
.a01a	85 04		sta $04				sta 	IF_Pos
.a01c	90 02		bcc $a020			bcc 	_IF_NoCarry 				; carry through.
.a01e	e6 05		inc $05				inc 	IF_Pos+1
.a020					_IF_NoCarry:
.a020	68		pla				pla
.a021	60		rts				rts
.a022					IF_Read:
.a022	5a		phy				phy 								; save current Y
.a023	a4 06		ldy $06				ldy 	IF_XPos 					; read character at current position
.a025	b1 04		lda ($04),y			lda 	(IF_Pos),y
.a027	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a029	7a		ply				ply									; restore Y
.a02a	60		rts				rts
.a02b					IF_Write:
.a02b	5a		phy				phy 								; save current Y
.a02c	a4 06		ldy $06				ldy 	IF_XPos 					; write character at current position
.a02e	91 04		sta ($04),y			sta 	(IF_Pos),y
.a030	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a032	7a		ply				ply									; restore Y
.a033	60		rts				rts
.a034					IF_LeftOne:
.a034	c6 06		dec $06				dec 	IF_XPos
.a036	60		rts				rts
.a037					IF_CheckBreak:
.a037	ad 01 88	lda $8801			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.a03a	60		rts				rts
.a03b					IF_GetKey:
.a03b	ad 00 88	lda $8800			lda 	IF_PKeyboard				; read keyboard
.a03e	f0 07		beq $a047			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.a040	48		pha				pha 								; key pressed, clear queue.
.a041	a9 00		lda #$00			lda 	#0
.a043	8d 00 88	sta $8800			sta 	IF_PKeyboard
.a046	68		pla				pla
.a047					_IFGK_NoKey:
.a047	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.a049	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: interface/interface_tools.asm

=$200					IFT_XCursor = $200								; current logical position on screen
=$201					IFT_YCursor = $201
=$202					IFT_Buffer = $202 								; scroll copy buffer.
=$280					IFT_LineBuffer = $280 							; line input buffer.
.a04a					IFT_ClearScreen:
.a04a	48		pha				pha
.a04b	da		phx				phx
.a04c	5a		phy				phy
.a04d	20 01 a0	jsr $a001			jsr 	IF_Home 					; home cursor
.a050	a2 19		ldx #$19			ldx 	#IF_Height 					; this many lines.
.a052					_IFT_CS0:
.a052	a0 50		ldy #$50			ldy 	#IF_Width 					; this many chars/line
.a054					_IFT_CS1:
.a054	a9 20		lda #$20			lda 	#' '						; clear line.
.a056	20 2b a0	jsr $a02b			jsr 	IF_Write
.a059	88		dey				dey
.a05a	d0 f8		bne $a054			bne 	_IFT_CS1
.a05c	20 10 a0	jsr $a010			jsr 	IF_NewLine 					; next line down
.a05f	ca		dex				dex
.a060	d0 f0		bne $a052			bne 	_IFT_CS0
.a062	7a		ply				ply
.a063	fa		plx				plx
.a064	68		pla				pla
.a065					IFT_HomeCursor:
.a065	48		pha				pha
.a066	20 01 a0	jsr $a001			jsr 	IF_Home
.a069	a9 00		lda #$00			lda 	#0
.a06b	8d 00 02	sta $0200			sta 	IFT_XCursor
.a06e	8d 01 02	sta $0201			sta 	IFT_YCursor
.a071	68		pla				pla
.a072	60		rts				rts
.a073					IFT_UpLine:
.a073	48		pha				pha
.a074	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.a077	3a		dec a				dec 	a 							; line above
.a078	30 03		bmi $a07d			bmi 	_IFTULExit 					; too far, abort
.a07a	20 0a a1	jsr $a10a			jsr 	IFT_SetYPos					; set to that line.
.a07d					_IFTULExit:
.a07d	68		pla				pla
.a07e	60		rts				rts
.a07f					IFT_PrintCharacter:
.a07f	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.a081	f0 18		beq $a09b			beq 	IFT_NewLine
.a083	48		pha				pha
.a084	20 b3 a0	jsr $a0b3			jsr 	IFT_UpperCase 				; make upper case
.a087	29 3f		and #$3f			and 	#63 						; make 6 bit PETSCII
.a089	20 2b a0	jsr $a02b			jsr 	IF_Write 					; write out.
.a08c	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.a08f	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.a092	c9 50		cmp #$50			cmp 	#IF_Width
.a094	d0 03		bne $a099			bne 	_IFT_PCNotEOL
.a096	20 9b a0	jsr $a09b			jsr 	IFT_NewLine 				; if so do new line.
.a099					_IFT_PCNotEOL:
.a099	68		pla				pla
.a09a	60		rts				rts
.a09b					IFT_NewLine:
.a09b	48		pha				pha
.a09c	20 10 a0	jsr $a010			jsr 	IF_NewLine 					; new line on actual screen.
.a09f	a9 00		lda #$00			lda 	#0 							; reset x position
.a0a1	8d 00 02	sta $0200			sta 	IFT_XCursor
.a0a4	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.a0a7	ad 01 02	lda $0201			lda 	IFT_YCursor
.a0aa	c9 19		cmp #$19			cmp 	#IF_Height 					; reached bottom.
.a0ac	d0 03		bne $a0b1			bne 	_IFT_NL_NotEOS
.a0ae	20 be a0	jsr $a0be			jsr 	IFT_Scroll 					; scroll screen up.
.a0b1					_IFT_NL_NotEOS:
.a0b1	68		pla				pla
.a0b2	60		rts				rts
.a0b3					IFT_UpperCase:
.a0b3	c9 61		cmp #$61			cmp 	#"a"
.a0b5	90 06		bcc $a0bd			bcc 	_IFT_UCExit
.a0b7	c9 7b		cmp #$7b			cmp 	#"z"+1
.a0b9	b0 02		bcs $a0bd			bcs 	_IFT_UCExit
.a0bb	49 20		eor #$20			eor 	#$20
.a0bd					_IFT_UCExit:
.a0bd	60		rts				rts
.a0be					IFT_Scroll:
.a0be	48		pha				pha 								; save AXY
.a0bf	da		phx				phx
.a0c0	5a		phy				phy
.a0c1	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.a0c3					_IFT_SLoop:
.a0c3	20 e3 a0	jsr $a0e3			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.a0c6	e8		inx				inx
.a0c7	e0 18		cpx #$18			cpx 	#IF_Height-1				; do whole screen
.a0c9	d0 f8		bne $a0c3			bne 	_IFT_SLoop
.a0cb	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a0cd	20 0a a1	jsr $a10a			jsr 	IFT_SetYPos
.a0d0	a2 50		ldx #$50			ldx 	#IF_Width 					; blank line
.a0d2					_IFT_SBlank:
.a0d2	a9 20		lda #$20			lda 	#32
.a0d4	20 2b a0	jsr $a02b			jsr 	IF_Write
.a0d7	ca		dex				dex
.a0d8	d0 f8		bne $a0d2			bne 	_IFT_SBlank
.a0da	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a0dc	20 0a a1	jsr $a10a			jsr 	IFT_SetYPos
.a0df	7a		ply				ply
.a0e0	fa		plx				plx
.a0e1	68		pla				pla
.a0e2	60		rts				rts
.a0e3					_IFT_ScrollLine:
.a0e3	da		phx				phx
.a0e4	da		phx				phx
.a0e5	8a		txa				txa 								; copy line into buffer.
.a0e6	1a		inc a				inc 	a 							; next line down.
.a0e7	20 0a a1	jsr $a10a			jsr 	IFT_SetYPos
.a0ea	a2 00		ldx #$00			ldx 	#0
.a0ec					_IFTScrollCopy1:
.a0ec	20 22 a0	jsr $a022			jsr 	IF_Read
.a0ef	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.a0f2	e8		inx				inx
.a0f3	e0 50		cpx #$50			cpx 	#IF_Width
.a0f5	d0 f5		bne $a0ec			bne 	_IFTScrollCopy1
.a0f7	68		pla				pla
.a0f8	20 0a a1	jsr $a10a			jsr 	IFT_SetYPos
.a0fb	a2 00		ldx #$00			ldx 	#0
.a0fd					_IFTScrollCopy2:
.a0fd	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.a100	20 2b a0	jsr $a02b			jsr 	IF_Write
.a103	e8		inx				inx
.a104	e0 50		cpx #$50			cpx 	#IF_Width
.a106	d0 f5		bne $a0fd			bne 	_IFTScrollCopy2
.a108	fa		plx				plx
.a109	60		rts				rts
.a10a					IFT_SetYPos:
.a10a	48		pha				pha
.a10b	da		phx				phx
.a10c	aa		tax				tax
.a10d	20 65 a0	jsr $a065			jsr 	IFT_HomeCursor
.a110	e0 00		cpx #$00			cpx 	#0
.a112	f0 09		beq $a11d			beq 	_IFT_MOAExit
.a114					_IFT_MOALoop:
.a114	20 10 a0	jsr $a010			jsr 	IF_NewLine
.a117	ee 01 02	inc $0201			inc 	IFT_YCursor
.a11a	ca		dex				dex
.a11b	d0 f7		bne $a114			bne		_IFT_MOALoop
.a11d					_IFT_MOAExit:
.a11d	fa		plx				plx
.a11e	68		pla				pla
.a11f	60		rts				rts
.a120					IFT_GetKeyCursor:
.a120	20 28 a1	jsr $a128			jsr 	_IFT_FlipCursor 			; reverse current
.a123					_IFT_GKCWait:
.a123	20 3b a0	jsr $a03b			jsr 	IF_GetKey 					; get key
.a126	f0 fb		beq $a123			beq 	_IFT_GKCWait
.a128					_IFT_FlipCursor:
.a128	48		pha				pha 								; save
.a129	20 22 a0	jsr $a022			jsr 	IF_Read 					; read
.a12c	20 34 a0	jsr $a034			jsr 	IF_LeftOne
.a12f	49 80		eor #$80			eor 	#$80 						; reverse
.a131	20 2b a0	jsr $a02b			jsr 	IF_Write 					; write
.a134	20 34 a0	jsr $a034			jsr 	IF_LeftOne
.a137	68		pla				pla
.a138	60		rts				rts
.a139					IFT_ReadLine:
.a139	48		pha				pha
.a13a					_IFT_RLLoop:
.a13a	20 20 a1	jsr $a120			jsr 	IFT_GetKeyCursor 			; get keystroke
.a13d	c9 0d		cmp #$0d			cmp 	#13							; return
.a13f	f0 7d		beq $a1be			beq 	_IFT_RLExit
.a141	c9 20		cmp #$20			cmp 	#32 						; control character
.a143	90 05		bcc $a14a			bcc 	_IFT_Control
.a145	20 7f a0	jsr $a07f			jsr 	IFT_PrintCharacter
.a148	80 f0		bra $a13a			bra 	_IFT_RLLoop
.a14a					_IFT_Control:
.a14a	c9 01		cmp #$01			cmp 	#"A"-64
.a14c	f0 26		beq $a174			beq 	_IFT_Left
.a14e	c9 04		cmp #$04			cmp 	#"D"-64
.a150	f0 2e		beq $a180			beq 	_IFT_Right
.a152	c9 17		cmp #$17			cmp 	#"W"-64
.a154	f0 36		beq $a18c			beq 	_IFT_Up
.a156	c9 13		cmp #$13			cmp 	#"S"-64
.a158	f0 3e		beq $a198			beq 	_IFT_Down
.a15a	c9 08		cmp #$08			cmp 	#"H"-64
.a15c	f0 09		beq $a167			beq 	_IFT_Backspace
.a15e	c9 1a		cmp #$1a			cmp 	#"Z"-64
.a160	d0 d8		bne $a13a			bne 	_IFT_RLLoop
.a162	20 4a a0	jsr $a04a			jsr 	IFT_ClearScreen				; clear CTL-Z
.a165	80 d3		bra $a13a			bra 	_IFT_RLLoop
.a167					_IFT_Backspace:
.a167	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.a16a	f0 ce		beq $a13a			beq 	_IFT_RLLoop
.a16c	20 34 a0	jsr $a034			jsr 	IF_LeftOne
.a16f	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.a171	20 2b a0	jsr $a02b			jsr 	IF_Write
.a174					_IFT_Left:
.a174	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.a177	10 29		bpl $a1a2			bpl 	_IFT_Reposition
.a179	a9 4f		lda #$4f			lda 	#IF_Width-1
.a17b					_IFT_SetX:
.a17b	8d 00 02	sta $0200			sta 	IFT_XCursor
.a17e	80 22		bra $a1a2			bra 	_IFT_Reposition
.a180					_IFT_Right:
.a180	ee 00 02	inc $0200			inc 	IFT_XCursor
.a183	ad 00 02	lda $0200			lda 	IFT_XCursor
.a186	49 50		eor #$50			eor 	#IF_Width
.a188	f0 f1		beq $a17b			beq 	_IFT_SetX
.a18a	80 16		bra $a1a2			bra 	_IFT_Reposition
.a18c					_IFT_Up:
.a18c	ce 01 02	dec $0201			dec 	IFT_YCursor
.a18f	10 11		bpl $a1a2			bpl 	_IFT_Reposition
.a191	a9 18		lda #$18			lda 	#IF_Height-1
.a193					_IFT_SetY:
.a193	8d 01 02	sta $0201			sta 	IFT_YCursor
.a196	80 0a		bra $a1a2			bra 	_IFT_Reposition
.a198					_IFT_Down:
.a198	ee 01 02	inc $0201			inc 	IFT_YCursor
.a19b	ad 01 02	lda $0201			lda 	IFT_YCursor
.a19e	49 19		eor #$19			eor 	#IF_Height
.a1a0	f0 f1		beq $a193			beq 	_IFT_SetY
.a1a2					_IFT_Reposition:
.a1a2	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.a1a5	48		pha				pha
.a1a6	ad 01 02	lda $0201			lda 	IFT_YCursor
.a1a9	20 0a a1	jsr $a10a			jsr 	IFT_SetYPos
.a1ac	68		pla				pla
.a1ad	aa		tax				tax
.a1ae	e0 00		cpx #$00			cpx 	#0
.a1b0	f0 88		beq $a13a			beq 	_IFT_RLLoop
.a1b2					_IFT_MoveRight:
.a1b2	20 22 a0	jsr $a022			jsr 	IF_Read
.a1b5	ee 00 02	inc $0200			inc 	IFT_XCursor
.a1b8	ca		dex				dex
.a1b9	d0 f7		bne $a1b2			bne 	_IFT_MoveRight
.a1bb	4c 3a a1	jmp $a13a			jmp 	_IFT_RLLoop
.a1be					_IFT_RLExit:
.a1be	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.a1c1	20 0a a1	jsr $a10a			jsr 	IFT_SetYPos
.a1c4	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.a1c6					_IFT_RLRead:
.a1c6	20 22 a0	jsr $a022			jsr 	IF_Read
.a1c9	18		clc				clc 								; convert back to ASCII.
.a1ca	49 20		eor #$20			eor 	#$20
.a1cc	69 20		adc #$20			adc 	#$20
.a1ce	9d 80 02	sta $0280,x			sta 	IFT_LineBuffer,x
.a1d1	e8		inx				inx
.a1d2	e0 50		cpx #$50			cpx 	#IF_Width
.a1d4	d0 f0		bne $a1c6			bne 	_IFT_RLRead
.a1d6					_IFT_RL_Trim:
.a1d6	ca		dex				dex 	 							; previous char
.a1d7	30 07		bmi $a1e0			bmi 	_IFT_Found 					; gone too far
.a1d9	bd 80 02	lda $0280,x			lda 	IFT_LineBuffer,x			; go back if space
.a1dc	c9 20		cmp #$20			cmp 	#" "
.a1de	f0 f6		beq $a1d6			beq 	_IFT_RL_Trim
.a1e0					_IFT_Found:
.a1e0	e8		inx				inx 								; forward to non-space
.a1e1	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.a1e3	9d 80 02	sta $0280,x			sta 	IFT_LineBuffer,x
.a1e6	68		pla				pla
.a1e7	a2 80		ldx #$80			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.a1e9	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.a1eb	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: utility/tim.asm

.a1ec					TIM_Error:
.a1ec	20 73 a0	jsr $a073			jsr 	IFT_UpLine 					; go up one line.
.a1ef	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.a1f1	80 02		bra $a1f5			bra 	TIM_ShowPrompt
.a1f3					TIM_NewCommand:
.a1f3	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.a1f5					TIM_ShowPrompt:
.a1f5	20 7f a0	jsr $a07f			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.a1f8	20 39 a1	jsr $a139			jsr 	IFT_ReadLine	 			; get character, go to next line
.a1fb	20 9b a0	jsr $a09b			jsr 	IFT_NewLine					; go to next line.
.a1fe	86 10		stx $10				stx 	zTemp1 						; save line read address
.a200	84 11		sty $11				sty 	zTemp1+1
.a202	a0 01		ldy #$01			ldy 	#1 							; get first character after the prompt.
.a204	b1 10		lda ($10),y			lda 	(zTemp1),y
.a206	c9 52		cmp #$52			cmp 	#"R"						; show registers
.a208	f0 6b		beq $a275			beq 	TIM_ShowRegisters
.a20a	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.a20c	f0 12		beq $a220			beq 	TIM_ShowMemory
.a20e	c9 47		cmp #$47			cmp 	#"G"						; execute
.a210	f0 49		beq $a25b			beq 	TIM_Execute
.a212	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.a214	f0 07		beq $a21d			beq 	TIM_GoLoadMemory
.a216	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.a218	d0 d2		bne $a1ec			bne 	TIM_Error
.a21a	4c 96 a3	jmp $a396			jmp 	TIM_UpdateRegisters
.a21d					TIM_GoLoadMemory:
.a21d	4c c1 a3	jmp $a3c1			jmp 	TIM_LoadMemory
.a220					TIM_ShowMemory:
.a220	20 12 a3	jsr $a312			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.a223	b0 c7		bcs $a1ec			bcs 	TIM_Error
.a225	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.a227	85 12		sta $12				sta 	zTemp2
.a229	a5 15		lda $15				lda 	zTemp3+1
.a22b	85 13		sta $13				sta 	zTemp2+1
.a22d	20 12 a3	jsr $a312			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.a230	90 08		bcc $a23a			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.a232	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.a234	85 14		sta $14				sta 	zTemp3
.a236	a5 13		lda $13				lda 	zTemp2+1
.a238	85 15		sta $15				sta 	zTemp3+1
.a23a					_TIMSM_Start:
.a23a	20 ea a2	jsr $a2ea			jsr 	TIM_WriteLine 				; write one line of hex out
.a23d	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.a23f	18		clc				clc
.a240	69 10		adc #$10			adc 	#16
.a242	85 12		sta $12				sta 	zTemp2
.a244	90 02		bcc $a248			bcc 	_TIMSM_NoCarry
.a246	e6 13		inc $13				inc 	zTemp2+1
.a248					_TIMSM_NoCarry:
.a248	20 37 a0	jsr $a037			jsr 	IF_CheckBreak 				; check CTL+C
.a24b	d0 0b		bne $a258			bne 	_TIMSM_Ends 				; if pressed break out.
.a24d	38		sec				sec 								; check past the end address in zTemp3
.a24e	a5 14		lda $14				lda 	zTemp3
.a250	e5 12		sbc $12				sbc 	zTemp2
.a252	a5 15		lda $15				lda 	zTemp3+1
.a254	e5 13		sbc $13				sbc 	zTemp2+1
.a256	10 e2		bpl $a23a			bpl 	_TIMSM_Start
.a258					_TIMSM_Ends:
.a258	4c f3 a1	jmp $a1f3			jmp 	TIM_NewCommand
.a25b					TIM_Execute:
.a25b	20 12 a3	jsr $a312			jsr 	TIM_GetHex 					; get the execute address
.a25e	b0 8c		bcs $a1ec			bcs 	TIM_Error 					; not legitimate
.a260	ae 2c 04	ldx $042c			ldx 	TIM_SP 						; set up SP
.a263	9a		txs				txs
.a264	ad 27 04	lda $0427			lda 	TIM_SR 						; Status for PLP
.a267	48		pha				pha
.a268	ad 28 04	lda $0428			lda 	TIM_A 						; restore AXYZ
.a26b	ae 29 04	ldx $0429			ldx 	TIM_X
.a26e	ac 2a 04	ldy $042a			ldy 	TIM_Y
.a271	28		plp				plp 								; and PS Byte.
.a272	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.a275					TIM_Start:
.a275					TIM_ShowRegisters:
.a275	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.a278	8d 26 04	sta $0426			sta 	TIM_IRQ+1
.a27b	ad ff ff	lda $ffff			lda 	$FFFF
.a27e	8d 25 04	sta $0425			sta 	TIM_IRQ
.a281	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.a283					_TIMSR_Text:
.a283	bd ae a2	lda $a2ae,x			lda 	_TIMSR_Label,x
.a286	20 7f a0	jsr $a07f			jsr 	IFT_PrintCharacter
.a289	e8		inx				inx
.a28a	e0 23		cpx #$23			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.a28c	d0 f5		bne $a283			bne 	_TIMSR_Text
.a28e	a2 00		ldx #$00			ldx 	#0 							; output Register Line.
.a290					_TIMSR_LoopSpace:
.a290	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.a292	b0 04		bcs $a298			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.a294	8a		txa				txa
.a295	4a		lsr a				lsr 	a
.a296	b0 05		bcs $a29d			bcs 	_TIMSR_NoSpace
.a298					_TIMSR_Space:
.a298	a9 20		lda #$20			lda 	#" "
.a29a	20 7f a0	jsr $a07f			jsr 	IFT_PrintCharacter
.a29d					_TIMSR_NoSpace:
.a29d	bd 23 04	lda $0423,x			lda 	TIM_PC,x 					; output hex value.
.a2a0	20 d1 a2	jsr $a2d1			jsr 	TIM_WriteHex
.a2a3	e8		inx				inx
.a2a4	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.a2a6	d0 e8		bne $a290			bne 	_TimSR_LoopSpace
.a2a8	20 9b a0	jsr $a09b			jsr 	IFT_NewLine 				; new line
.a2ab	4c f3 a1	jmp $a1f3			jmp	 	TIM_NewCommand 				; new command.
.a2ae					_TIMSR_Label:
>a2ae	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR ZR SP",13,".; "
>a2b6	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>a2c6	52 20 5a 52 20 53 50 0d 2e 3b 20
.a2d1					_TIMSR_LabelEnd:
.a2d1					TIM_WriteHex:
.a2d1	48		pha				pha 								; save A
.a2d2	4a		lsr a				lsr 	a 							; shift MSB->LSB
.a2d3	4a		lsr a				lsr 	a
.a2d4	4a		lsr a				lsr 	a
.a2d5	4a		lsr a				lsr 	a
.a2d6	20 da a2	jsr $a2da			jsr 	_TIMWH_Nibble 				; print MSB
.a2d9	68		pla				pla 								; restore and print LSB
.a2da					_TIMWH_Nibble:
.a2da	48		pha				pha
.a2db	29 0f		and #$0f			and 	#15 						; mask out
.a2dd	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.a2df	90 02		bcc $a2e3			bcc 	_TIMWHNoLetter
.a2e1	69 06		adc #$06			adc 	#6
.a2e3					_TIMWHNoLetter:
.a2e3	69 30		adc #$30			adc 	#48
.a2e5	20 7f a0	jsr $a07f			jsr 	IFT_PrintCharacter 			; print it out.
.a2e8	68		pla				pla
.a2e9	60		rts				rts
.a2ea					TIM_WriteLine:
.a2ea	a9 2e		lda #$2e			lda 	#"." 						; prompt
.a2ec	20 7f a0	jsr $a07f			jsr 	IFT_PrintCharacter
.a2ef	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.a2f1	20 7f a0	jsr $a07f			jsr 	IFT_PrintCharacter
.a2f4	a5 13		lda $13				lda 	zTemp2+1 					; write address
.a2f6	20 d1 a2	jsr $a2d1			jsr 	TIM_WriteHex
.a2f9	a5 12		lda $12				lda 	zTemp2
.a2fb	20 d1 a2	jsr $a2d1			jsr 	TIM_WriteHex
.a2fe	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.a300					_TIMWL_Loop:
.a300	a9 20		lda #$20			lda 	#" "
.a302	20 7f a0	jsr $a07f			jsr 	IFT_PrintCharacter
.a305	b1 12		lda ($12),y			lda 	(zTemp2),y
.a307	20 d1 a2	jsr $a2d1			jsr 	TIM_WriteHex
.a30a	c8		iny				iny
.a30b	c0 10		cpy #$10			cpy 	#16
.a30d	d0 f1		bne $a300			bne 	_TIMWL_Loop
.a30f	4c 9b a0	jmp $a09b			jmp 	IFT_NewLine 				; new line and exit
.a312					TIM_GetHex:
.a312	c8		iny				iny
.a313	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.a315	c9 20		cmp #$20			cmp 	#32
.a317	f0 f9		beq $a312			beq 	TIM_GetHex
.a319	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.a31b	f0 f5		beq $a312			beq 	TIM_GetHex
.a31d	20 46 a3	jsr $a346			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.a320	b0 23		bcs $a345			bcs 	_TIMGH_Exit					; if first bad then exit now.
.a322	a9 00		lda #$00			lda 	#0 							; zero result
.a324	85 14		sta $14				sta 	zTemp3
.a326	85 15		sta $15				sta 	zTemp3+1
.a328					_TIM_GHLoop:
.a328	20 46 a3	jsr $a346			jsr 	TIM_GetHexCharacter 		; get next character
.a32b	b0 17		bcs $a344			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.a32d	c8		iny				iny 								; skip over it.
.a32e	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.a330	26 15		rol $15				rol 	zTemp3+1
.a332	06 14		asl $14				asl 	zTemp3 						; now x 2
.a334	26 15		rol $15				rol 	zTemp3+1
.a336	06 14		asl $14				asl 	zTemp3						; now x 4
.a338	26 15		rol $15				rol 	zTemp3+1
.a33a	06 14		asl $14				asl 	zTemp3 						; now x 8
.a33c	26 15		rol $15				rol 	zTemp3+1
.a33e	05 14		ora $14				ora 	zTemp3 						; OR result in
.a340	85 14		sta $14				sta 	zTemp3
.a342	80 e4		bra $a328			bra 	_TIM_GHLoop 				; loop round again.
.a344					_TIMGH_Okay:
.a344	18		clc				clc
.a345					_TIMGH_Exit:
.a345	60		rts				rts
.a346					TIM_GetHexCharacter:
.a346	b1 10		lda ($10),y			lda 	(zTemp1),y
.a348	38		sec				sec
.a349	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.a34b	90 0e		bcc $a35b			bcc 	_TIM_GHCFail
.a34d	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.a34f	90 0b		bcc $a35c			bcc 	_TIM_GHCExit
.a351	c9 11		cmp #$11			cmp 	#65-48						; < A
.a353	90 06		bcc $a35b			bcc		_TIM_GHCFail
.a355	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.a357	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.a359	90 01		bcc $a35c			bcc		_TIM_GHCExit
.a35b					_TIM_GHCFail:
.a35b	38		sec				sec
.a35c					_TIM_GHCExit:
.a35c	60		rts				rts
.a35d					TIM_BreakVector:
.a35d	da		phx				phx									; save X/A on stack
.a35e	48		pha				pha
.a35f	ba		tsx				tsx 								; X points to S
.a360	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.a363	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.a365	d0 03		bne $a36a			bne 	_TIMBreak					; if set, it's BRK
.a367	68		pla				pla 								; abandon routine.
.a368	fa		plx				plx
.a369	40		rti				rti
.a36a					_TIMBreak:
.a36a	68		pla				pla 								; save A X Y and maybe Z
.a36b	8d 28 04	sta $0428			sta 	TIM_A
.a36e	fa		plx				plx
.a36f	8e 29 04	stx $0429			stx 	TIM_X
.a372	8c 2a 04	sty $042a			sty 	TIM_Y
.a375	68		pla				pla 								; get Status Register
.a376	8d 27 04	sta $0427			sta 	TIM_SR
.a379	68		pla				pla
.a37a	8d 24 04	sta $0424			sta 	TIM_PC+1 					; save calling address
.a37d	68		pla				pla
.a37e	8d 23 04	sta $0423			sta 	TIM_PC 						; high byte
.a381	ad 24 04	lda $0424			lda 	TIM_PC+1 					; dec PC to point right.
.a384	d0 03		bne $a389			bne 	_TIMDecrement 				; brk bumps it.
.a386	ce 23 04	dec $0423			dec 	TIM_PC
.a389					_TIMDecrement:
.a389	ce 24 04	dec $0424			dec 	TIM_PC+1
.a38c	ba		tsx				tsx 								; and copy SP
.a38d	8e 2c 04	stx $042c			stx 	TIM_SP
.a390	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.a392	9a		txs				txs
.a393	4c 75 a2	jmp $a275			jmp 	TIM_Start 					; and start up TIM monitor.
.a396					TIM_UpdateRegisters:
.a396	20 12 a3	jsr $a312			jsr 	TIM_GetHex 					; PC
.a399	b0 23		bcs $a3be			bcs 	_TIMURFail
.a39b	a5 14		lda $14				lda 	zTemp3
.a39d	8d 24 04	sta $0424			sta 	Tim_PC+1
.a3a0	a5 15		lda $15				lda 	zTemp3+1
.a3a2	8d 23 04	sta $0423			sta 	Tim_PC
.a3a5	20 12 a3	jsr $a312			jsr 	TIM_GetHex 					; ignore IRQ
.a3a8	b0 14		bcs $a3be			bcs 	_TIMURFail
.a3aa	a2 00		ldx #$00			ldx 	#0
.a3ac					_TIM_URLoop:
.a3ac	20 12 a3	jsr $a312			jsr 	TIM_GetHex 					; registers
.a3af	b0 0d		bcs $a3be			bcs 	_TIMURFail
.a3b1	a5 14		lda $14				lda 	zTemp3
.a3b3	9d 27 04	sta $0427,x			sta 	Tim_SR,x
.a3b6	e8		inx				inx
.a3b7	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.a3b9	d0 f1		bne $a3ac			bne 	_TIM_URLoop
.a3bb	4c f3 a1	jmp $a1f3			jmp 	TIM_NewCommand
.a3be					_TIMURFail:
.a3be	4c ec a1	jmp $a1ec			jmp 	TIM_Error
.a3c1					TIM_LoadMemory:
.a3c1	20 12 a3	jsr $a312			jsr 	TIM_GetHex 					; target address => zTemp2
.a3c4	a5 14		lda $14				lda 	zTemp3
.a3c6	85 12		sta $12				sta 	zTemp2
.a3c8	a5 15		lda $15				lda 	zTemp3+1
.a3ca	85 13		sta $13				sta 	zTemp2+1
.a3cc					_TIM_LMLoop:
.a3cc	20 12 a3	jsr $a312			jsr 	TIM_GetHex 					; next byte ?
.a3cf	b0 0e		bcs $a3df			bcs 	_TIMLMDone 					; no more
.a3d1	a2 00		ldx #$00			ldx 	#0							; write out.
.a3d3	a5 14		lda $14				lda 	zTemp3
.a3d5	81 12		sta ($12,x)			sta 	(zTemp2,x)
.a3d7	e6 12		inc $12				inc 	zTemp2 						; bump address
.a3d9	d0 f1		bne $a3cc			bne 	_TIM_LMLoop
.a3db	e6 13		inc $13				inc 	zTemp2+1
.a3dd	80 ed		bra $a3cc			bra 	_TIM_LMLoop
.a3df					_TIMLMDone:
.a3df	4c f3 a1	jmp $a1f3			jmp 	TIM_NewCommand

;******  Return to file: basic.asm


;******  Processing file: testing/fptest.asm

.a3e2					FPTTest:
.a3e2	a9 9a		lda #$9a			lda 	#FPTTestData & $FF 			; set zGenPtr to data.
.a3e4	85 1a		sta $1a				sta 	zGenPtr
.a3e6	a9 a4		lda #$a4			lda 	#FPTTestData >> 8
.a3e8	85 1b		sta $1b				sta 	zGenPtr+1
.a3ea	a2 00		ldx #$00			ldx 	#0 							; start at stack bottom.
.a3ec	a5 1b		lda $1b		FPTLoop:lda 	zGenPtr+1
.a3ee	20 d1 a2	jsr $a2d1			jsr 	TIM_WriteHex
.a3f1	a5 1a		lda $1a				lda 	zGenPtr
.a3f3	20 d1 a2	jsr $a2d1			jsr 	TIM_WriteHex
.a3f6	a9 2e		lda #$2e			lda 	#"."
.a3f8	20 7f a0	jsr $a07f			jsr		IFT_PrintCharacter
.a3fb	20 8b a4	jsr $a48b			jsr 	FPTGet 						; get next command
.a3fe	c9 00		cmp #$00			cmp 	#0 							; zero, exit
.a400	f0 58		beq $a45a			beq 	FPTExit
.a402	c9 01		cmp #$01			cmp 	#1 							; 1,load
.a404	f0 46		beq $a44c			beq 	FPTLoad
.a406	c9 2b		cmp #$2b			cmp 	#"+" 						; the -1/0/1 value in AC.
.a408	d0 0b		bne $a415			bne 	_skip1
.a40a	20 7f a4	jsr $a47f			jsr 	FPT_Preamble
.a40d	20 cb a7	jsr $a7cb			jsr 	FPAdd
.a410	20 85 a4	jsr $a485			jsr 	FPT_Postamble
.a413	80 d7		bra $a3ec			bra 	FPTLoop
.a415					_skip1:
.a415	c9 2d		cmp #$2d			cmp 	#"-" 						; the -1/0/1 value in AC.
.a417	d0 0b		bne $a424			bne 	_skip1
.a419	20 7f a4	jsr $a47f			jsr 	FPT_Preamble
.a41c	20 c1 a7	jsr $a7c1			jsr 	FPSubtract
.a41f	20 85 a4	jsr $a485			jsr 	FPT_Postamble
.a422	80 c8		bra $a3ec			bra 	FPTLoop
.a424					_skip1:
.a424	c9 2a		cmp #$2a			cmp 	#"*" 						; the -1/0/1 value in AC.
.a426	d0 0b		bne $a433			bne 	_skip1
.a428	20 7f a4	jsr $a47f			jsr 	FPT_Preamble
.a42b	20 9b a8	jsr $a89b			jsr 	FPMultiply
.a42e	20 85 a4	jsr $a485			jsr 	FPT_Postamble
.a431	80 b9		bra $a3ec			bra 	FPTLoop
.a433					_skip1:
.a433	c9 2f		cmp #$2f			cmp 	#"/" 						; the -1/0/1 value in AC.
.a435	d0 0b		bne $a442			bne 	_skip1
.a437	20 7f a4	jsr $a47f			jsr 	FPT_Preamble
.a43a	20 4c a9	jsr $a94c			jsr 	FPDivide
.a43d	20 85 a4	jsr $a485			jsr 	FPT_Postamble
.a440	80 aa		bra $a3ec			bra 	FPTLoop
.a442					_skip1:
.a442	c9 7e		cmp #$7e			cmp 	#"~" 						; ~, compare
.a444	f0 1a		beq $a460			beq 	FPTCompare
.a446	c9 3d		cmp #$3d			cmp 	#"="						; = check equal
.a448	f0 28		beq $a472			beq 	FPTCheck
.a44a					FPTError:
.a44a	80 fe		bra $a44a			bra 	FPTError
.a44c					FPTLoad:
.a44c	a0 06		ldy #$06			ldy 	#6 							; data to copy
.a44e					_FPTLoadLoop:
.a44e	20 8b a4	jsr $a48b			jsr 	FPTGet
.a451	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.a454	e8		inx				inx
.a455	88		dey				dey
.a456	d0 f6		bne $a44e			bne 	_FPTLoadLoop
.a458	80 92		bra $a3ec			bra 	FPTLoop
.a45a					FPTExit:
.a45a	a9 2a		lda #$2a			lda 	#42
.a45c	20 7f a0	jsr $a07f			jsr 	IFT_PrintCharacter
.a45f	60		rts				rts
.a460					FPTCompare:
.a460	20 7f a4	jsr $a47f			jsr 	FPT_Preamble
.a463	20 d4 a9	jsr $a9d4			jsr 	FPCompare
.a466	20 17 a6	jsr $a617			jsr 	FPUSetInteger
.a469	20 55 a6	jsr $a655			jsr 	FPUToFloat
.a46c	20 85 a4	jsr $a485			jsr 	FPT_Postamble
.a46f	4c ec a3	jmp $a3ec			jmp 	FPTLoop
.a472					FPTCheck:
.a472	20 7f a4	jsr $a47f			jsr 	FPT_Preamble
.a475	20 d4 a9	jsr $a9d4			jsr 	FPCompare
.a478	09 00		ora #$00			ora 	#0
.a47a					_FPTCFail:
.a47a	d0 fe		bne $a47a			bne 	_FPTCFail
.a47c	4c ec a3	jmp $a3ec			jmp 	FPTLoop
.a47f					FPT_Preamble:
.a47f	8a		txa				txa
.a480	38		sec				sec
.a481	e9 0c		sbc #$0c			sbc 	#12
.a483	aa		tax				tax
.a484	60		rts				rts
.a485					FPT_Postamble:
.a485	8a		txa				txa
.a486	18		clc				clc
.a487	69 06		adc #$06			adc 	#6
.a489	aa		tax				tax
.a48a	60		rts				rts
.a48b	5a		phy		FPTGet:	phy
.a48c	a0 00		ldy #$00			ldy 	#0
.a48e	b1 1a		lda ($1a),y			lda 	(zGenPtr),y
.a490	48		pha				pha
.a491	e6 1a		inc $1a				inc 	zGenPtr
.a493	d0 02		bne $a497			bne 	_FPTGet1
.a495	e6 1b		inc $1b				inc 	zGenPtr+1
.a497					_FPTGet1:
.a497	68		pla				pla
.a498	7a		ply				ply
.a499	60		rts				rts
.a49a					FPTTestData:

;******  Processing file: testing/script.inc

>a49a	01					.byte 	1     ; *** Load Float 99.94 ***
>a49b	ae 47 e1 c7				.dword 	$c7e147ae
>a49f	87 00					.byte 	$87,$0
>a4a1	01					.byte 	1     ; *** Load Float 123456.798 ***
>a4a2	24 66 20 f1				.dword 	$f1206624
>a4a6	91 00					.byte 	$91,$0
>a4a8	00					.byte 	0

;******  Return to file: testing/fptest.asm

>a4a9	00						.byte 	0

;******  Return to file: basic.asm


;******  Processing file: integer/inttostr.asm

.a4aa					INTToString:
.a4aa	48		pha				pha
.a4ab	5a		phy				phy
.a4ac	bd 03 03	lda $0303,x			lda 		XS_Mantissa+3,x 		; check -ve
.a4af	10 08		bpl $a4b9			bpl 		_ITSNotMinus
.a4b1	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.a4b3	20 46 a5	jsr $a546			jsr 		ITSOutputCharacter
.a4b6	20 31 a6	jsr $a631			jsr 		FPUNegateInteger
.a4b9					_ITSNotMinus:
.a4b9	a9 00		lda #$00			lda 		#0 						; X is offset in table.
.a4bb	8d 21 04	sta $0421			sta 		NumSuppress 			; clear the suppression flag.
.a4be	a0 00		ldy #$00			ldy 		#0 						; Y is index into dword subtraction table.
.a4c0					_ITSNextSubtractor:
.a4c0	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.a4c2	8d 22 04	sta $0422			sta 		NumConvCount
.a4c5					_ITSSubtract:
.a4c5	38		sec				sec
.a4c6	bd 00 03	lda $0300,x			lda 		XS_Mantissa,x 			; subtract number and push on stack
.a4c9	f9 22 a5	sbc $a522,y			sbc 		_ITSSubtractors+0,y
.a4cc	48		pha				pha
.a4cd	bd 01 03	lda $0301,x			lda 		XS_Mantissa+1,x
.a4d0	f9 23 a5	sbc $a523,y			sbc 		_ITSSubtractors+1,y
.a4d3	48		pha				pha
.a4d4	bd 02 03	lda $0302,x			lda 		XS_Mantissa+2,x
.a4d7	f9 24 a5	sbc $a524,y			sbc 		_ITSSubtractors+2,y
.a4da	48		pha				pha
.a4db	bd 03 03	lda $0303,x			lda 		XS_Mantissa+3,x
.a4de	f9 25 a5	sbc $a525,y			sbc 		_ITSSubtractors+3,y
.a4e1	90 14		bcc $a4f7			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.a4e3	9d 03 03	sta $0303,x			sta 		XS_Mantissa+3,x 		; save subtract off stack
.a4e6	68		pla				pla
.a4e7	9d 02 03	sta $0302,x			sta 		XS_Mantissa+2,x
.a4ea	68		pla				pla
.a4eb	9d 01 03	sta $0301,x			sta 		XS_Mantissa+1,x
.a4ee	68		pla				pla
.a4ef	9d 00 03	sta $0300,x			sta 		XS_Mantissa+0,x
.a4f2	ee 22 04	inc $0422			inc 		NumConvCount 			; bump count.
.a4f5	80 ce		bra $a4c5			bra 		_ITSSubtract 			; go round again.
.a4f7					_ITSCantSubtract:
.a4f7	68		pla				pla 								; throw away interim answers
.a4f8	68		pla				pla
.a4f9	68		pla				pla
.a4fa	ad 22 04	lda $0422			lda 		NumConvCount 			; if not zero then no suppression check
.a4fd	c9 30		cmp #$30			cmp 		#"0"
.a4ff	d0 05		bne $a506			bne 		_ITSOutputDigit
.a501	ad 21 04	lda $0421			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.a504	10 09		bpl $a50f			bpl 		_ITSGoNextSubtractor
.a506					_ITSOutputDigit:
.a506	ce 21 04	dec $0421			dec 		NumSuppress 			; suppression check will be non-zero.
.a509	ad 22 04	lda $0422			lda 		NumConvCount 			; count of subtractions
.a50c	20 46 a5	jsr $a546			jsr 		ITSOutputCharacter 		; output it.
.a50f					_ITSGoNextSubtractor:
.a50f	c8		iny				iny 								; next dword
.a510	c8		iny				iny
.a511	c8		iny				iny
.a512	c8		iny				iny
.a513	c0 24		cpy #$24			cpy 		#_ITSSubtractorsEnd-_ITSSubtractors
.a515	d0 a9		bne $a4c0			bne 		_ITSNextSubtractor 		; do all the subtractors.
.a517	bd 00 03	lda $0300,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.a51a	09 30		ora #$30			ora 		#"0"
.a51c	20 46 a5	jsr $a546			jsr 		ITSOutputCharacter
.a51f	7a		ply				ply 								; and exit
.a520	68		pla				pla
.a521	60		rts				rts
.a522					_ITSSubtractors:
>a522	00 ca 9a 3b					.dword 		1000000000
>a526	00 e1 f5 05					.dword 		100000000
>a52a	80 96 98 00					.dword 		10000000
>a52e	40 42 0f 00					.dword 		1000000
>a532	a0 86 01 00					.dword 		100000
>a536	10 27 00 00					.dword 		10000
>a53a	e8 03 00 00					.dword 		1000
>a53e	64 00 00 00					.dword 		100
>a542	0a 00 00 00					.dword 		10
.a546					_ITSSubtractorsEnd:
.a546					ITSOutputCharacter:
.a546	48		pha				pha
.a547	da		phx				phx
.a548	ae 20 04	ldx $0420			ldx 	NumBufX 					; save digit
.a54b	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.a54e	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.a550	9d 01 04	sta $0401,x			sta 	Num_Buffer+1,x
.a553	ee 20 04	inc $0420			inc 	NumBufX						; bump pointer.
.a556	fa		plx				plx
.a557	68		pla				pla
.a558	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: integer/intfromstr.asm

.a559					IntFromString:
.a559	a0 00		ldy #$00			ldy 	#0
.a55b	8c 2d 04	sty $042d			sty 	ExpTemp 					; this is the converted digit count.
.a55e					IntFromStringY:
.a55e	48		pha				pha
.a55f	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.a561	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.a564	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.a567	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.a56a	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.a56d	a9 01		lda #$01			lda 	#1
.a56f	9d 05 03	sta $0305,x			sta 	XS_Type,x
.a572					_IFSLoop:
.a572	b1 1a		lda ($1a),y			lda 	(zGenPtr),y 				; get next
.a574	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.a576	90 60		bcc $a5d8			bcc 	_IFSExit
.a578	c9 3a		cmp #$3a			cmp 	#"9"+1
.a57a	b0 5c		bcs $a5d8			bcs 	_IFSExit
.a57c	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.a57f	c9 0c		cmp #$0c			cmp 	#12
.a581	b0 5f		bcs $a5e2			bcs 	_IFSOverflow
.a583	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.a586	48		pha				pha
.a587	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.a58a	48		pha				pha
.a58b	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.a58e	48		pha				pha
.a58f	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.a592	48		pha				pha
.a593	20 f7 a5	jsr $a5f7			jsr 	IFSX1ShiftLeft 				; double
.a596	20 f7 a5	jsr $a5f7			jsr 	IFSX1ShiftLeft 				; x 4
.a599	18		clc				clc 								; add saved value x 5
.a59a	68		pla				pla
.a59b	7d 00 03	adc $0300,x			adc 	XS_Mantissa+0,x
.a59e	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.a5a1	68		pla				pla
.a5a2	7d 01 03	adc $0301,x			adc 	XS_Mantissa+1,x
.a5a5	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.a5a8	68		pla				pla
.a5a9	7d 02 03	adc $0302,x			adc 	XS_Mantissa+2,x
.a5ac	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.a5af	68		pla				pla
.a5b0	7d 03 03	adc $0303,x			adc 	XS_Mantissa+3,x
.a5b3	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.a5b6	20 f7 a5	jsr $a5f7			jsr 	IFSX1ShiftLeft 				; x 10
.a5b9	ee 2d 04	inc $042d			inc 	ExpTemp 					; bump count of digits processed.
.a5bc	b1 1a		lda ($1a),y			lda 	(zGenPtr),y 				; add digit
.a5be	29 0f		and #$0f			and 	#15
.a5c0	c8		iny				iny
.a5c1	7d 00 03	adc $0300,x			adc 	XS_Mantissa+0,x
.a5c4	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.a5c7	90 a9		bcc $a572			bcc 	_IFSLoop
.a5c9	fe 01 03	inc $0301,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.a5cc	d0 a4		bne $a572			bne 	_IFSLoop
.a5ce	fe 02 03	inc $0302,x			inc 	XS_Mantissa+2,x
.a5d1	d0 9f		bne $a572			bne 	_IFSLoop
.a5d3	fe 03 03	inc $0303,x			inc 	XS_Mantissa+3,x
.a5d6	80 9a		bra $a572			bra 	_IFSLoop
.a5d8					_IFSExit:
.a5d8	98		tya				tya 								; get offset
.a5d9					_IFSOkay:
.a5d9	38		sec				sec
.a5da	ad 2d 04	lda $042d			lda 	ExpTemp
.a5dd	f0 01		beq $a5e0			beq 	_IFSSkipFail
.a5df	18		clc				clc
.a5e0					_IFSSkipFail:
.a5e0	68		pla				pla 								; and exit.
.a5e1	60		rts				rts
.a5e2					_IFSOverflow:
.a5e2	20 46 ab	jsr $ab46			jsr 	ERR_Handler
>a5e5	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>a5ed	20 6f 76 65 72 66 6c 6f 77 00
.a5f7					IFSX1ShiftLeft:
.a5f7	1e 00 03	asl $0300,x			asl 	0+XS_Mantissa,x
.a5fa	3e 01 03	rol $0301,x			rol 	1+XS_Mantissa,x
.a5fd	3e 02 03	rol $0302,x			rol 	2+XS_Mantissa,x
.a600	3e 03 03	rol $0303,x			rol 	3+XS_Mantissa,x
.a603	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: float/fpmacros.asm


;******  Return to file: basic.asm


;******  Processing file: float/fputils.asm

.a604					FPUCopyX2ToX1:
.a604	48		pha				pha
.a605	da		phx				phx
.a606	5a		phy				phy
.a607	a0 08		ldy #$08			ldy 	#8
.a609	bd 06 03	lda $0306,x	_FPUC21:lda 	XS2_Mantissa,x
.a60c	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.a60f	e8		inx				inx
.a610	88		dey				dey
.a611	10 f6		bpl $a609			bpl 	_FPUC21
.a613	7a		ply				ply
.a614	fa		plx				plx
.a615	68		pla				pla
.a616	60		rts				rts
.a617					FPUSetInteger:
.a617	48		pha				pha
.a618	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.a61b	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.a61d	10 02		bpl $a621			bpl 	_FPUSIExtend
.a61f	a9 ff		lda #$ff			lda 	#$FF
.a621					_FPUSIExtend:
.a621	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.a624	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.a627	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.a62a	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.a62c	9d 05 03	sta $0305,x			sta 	XS_Type,x
.a62f	68		pla				pla
.a630	60		rts				rts
.a631					FPUNegateInteger:
.a631	48		pha				pha
.a632	38		sec				sec
.a633	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.a635	fd 00 03	sbc $0300,x			sbc 	XS_Mantissa+0,x
.a638	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.a63b	a9 00		lda #$00			lda 	#0
.a63d	fd 01 03	sbc $0301,x			sbc 	XS_Mantissa+1,x
.a640	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.a643	a9 00		lda #$00			lda 	#0
.a645	fd 02 03	sbc $0302,x			sbc 	XS_Mantissa+2,x
.a648	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.a64b	a9 00		lda #$00			lda 	#0
.a64d	fd 03 03	sbc $0303,x			sbc 	XS_Mantissa+3,x
.a650	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.a653	68		pla				pla
.a654	60		rts				rts
.a655					FPUToFloat:
.a655	48		pha				pha
.a656	bd 05 03	lda $0305,x			lda 	XS_Type,x					; exit if already float.
.a659	29 0f		and #$0f			and 	#$0F
.a65b	f0 2d		beq $a68a			beq 	_FPUFExit
.a65d	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.a65f	9d 05 03	sta $0305,x			sta 	XS_Type,x
.a662	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.a664	9d 04 03	sta $0304,x			sta 	XS_Exponent,x 				; x mantissa.
.a667	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.a66a	10 08		bpl $a674			bpl		_FPUFPositive
.a66c	20 31 a6	jsr $a631			jsr 	FPUNegateInteger 			; negate the mantissa
.a66f	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.a671	9d 05 03	sta $0305,x			sta 	XS_Type,x
.a674					_FPUFPositive:
.a674	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.a677	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.a67a	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.a67d	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.a680	d0 05		bne $a687			bne 	_FPUFNonZero
.a682	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.a684	9d 05 03	sta $0305,x			sta 	XS_Type,x
.a687					_FPUFNonZero:
.a687	20 8c a6	jsr $a68c			jsr 	FPUNormalise 				; normalise the floating point.
.a68a					_FPUFExit:
.a68a	68		pla				pla
.a68b	60		rts				rts
.a68c					FPUNormalise:
.a68c	48		pha				pha
.a68d	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.a690	70 20		bvs $a6b2			bvs 	_FPUNExit
.a692	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.a695	f0 16		beq $a6ad			beq 	_FPUNSetZero
.a697					_FPUNLoop:
.a697	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.a69a	30 16		bmi $a6b2			bmi 	_FPUNExit 					; if so, we are normalised.
.a69c	1e 00 03	asl $0300,x			asl 	0+XS_Mantissa+0,x
.a69f	3e 01 03	rol $0301,x			rol 	1+XS_Mantissa+0,x
.a6a2	3e 02 03	rol $0302,x			rol 	2+XS_Mantissa+0,x
.a6a5	3e 03 03	rol $0303,x			rol 	3+XS_Mantissa+0,x
.a6a8	de 04 03	dec $0304,x			dec 	XS_Exponent,x 				; decrement exponent
.a6ab	d0 ea		bne $a697			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.a6ad					_FPUNSetZero:
.a6ad	a9 40		lda #$40			lda 	#$40
.a6af	9d 05 03	sta $0305,x			sta 	XS_Type,x 					; the result is now zero.
.a6b2					_FPUNExit:
.a6b2	68		pla				pla
.a6b3	60		rts				rts
.a6b4					FPUToInteger:
.a6b4	48		pha				pha
.a6b5	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; if already integer, exit
.a6b8	29 01		and #$01			and 	#1
.a6ba	d0 3e		bne $a6fa			bne 	_FPUTOI_Exit
.a6bc	3c 05 03	bit $0305,x			bit 	XS_Type,x					; if zero, return zero.
.a6bf	70 2b		bvs $a6ec			bvs 	_FPUTOI_Zero
.a6c1	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.a6c4	10 26		bpl $a6ec			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.a6c6	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.a6c8	b0 37		bcs $a701			bcs 	FP_Overflow
.a6ca					_FPUToIToInteger:
.a6ca	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.a6cd	c9 a0		cmp #$a0			cmp 	#128+32
.a6cf	f0 11		beq $a6e2			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.a6d1	fe 04 03	inc $0304,x			inc 	XS_Exponent,X 				; increment Exponent
.a6d4	5e 03 03	lsr $0303,x			lsr 	3+XS_Mantissa,x
.a6d7	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.a6da	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.a6dd	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.a6e0	80 e8		bra $a6ca			bra 	_FPUToIToInteger 			; keep going.
.a6e2					_FPUToICheckSign:
.a6e2	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; check sign
.a6e5	10 13		bpl $a6fa			bpl 	_FPUToI_Exit 				; exit if unsigned.
.a6e7	20 31 a6	jsr $a631			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.a6ea	80 0e		bra $a6fa			bra 	_FPUTOI_Exit
.a6ec					_FPUTOI_Zero:
.a6ec	a9 00		lda #$00			lda 	#0 							; return zero integer.
.a6ee	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.a6f1	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.a6f4	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.a6f7	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.a6fa					_FPUToI_Exit:
.a6fa	a9 01		lda #$01			lda 	#1 							; set type to integer
.a6fc	9d 05 03	sta $0305,x			sta 	XS_Type,x
.a6ff	68		pla				pla
.a700	60		rts				rts
.a701					FP_Overflow:
.a701	20 46 ab	jsr $ab46			jsr 	ERR_Handler
>a704	46 6c 6f 61 74 69 6e 67				.text 	"Floating Point overflow",0
>a70c	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.a71c					FPUTimes10:
.a71c	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.a71f	85 16		sta $16				sta 	ZLTemp1+0
.a721	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.a724	85 17		sta $17				sta 	ZLTemp1+1
.a726	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.a729	85 18		sta $18				sta 	ZLTemp1+2
.a72b	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.a72e	85 19		sta $19				sta 	ZLTemp1+3
.a730	20 74 a7	jsr $a774			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.a733	20 74 a7	jsr $a774			jsr 	_FPUT_LSR_ZLTemp1
.a736	18		clc				clc
.a737	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.a73a	65 16		adc $16				adc 	ZLTemp1+0
.a73c	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.a73f	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.a742	65 17		adc $17				adc 	ZLTemp1+1
.a744	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.a747	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.a74a	65 18		adc $18				adc 	ZLTemp1+2
.a74c	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.a74f	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.a752	65 19		adc $19				adc 	ZLTemp1+3
.a754	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.a757	90 0f		bcc $a768			bcc 	_FPUTimes10
.a759	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.a75c	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.a75f	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.a762	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.a765	fe 04 03	inc $0304,x			inc 	XS_Exponent,x				; fix exponent
.a768					_FPUTimes10:
.a768	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.a76b	18		clc				clc
.a76c	69 03		adc #$03			adc 	#3
.a76e	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.a771	b0 8e		bcs $a701			bcs 	FP_Overflow 				; error
.a773	60		rts				rts
.a774					_FPUT_LSR_ZLTemp1:
.a774	46 19		lsr $19				lsr 	ZLTemp1+3
.a776	66 18		ror $18				ror 	ZLTemp1+2
.a778	66 17		ror $17				ror 	ZLTemp1+1
.a77a	66 16		ror $16				ror 	ZLTemp1+0
.a77c	60		rts				rts
.a77d					FPUScale10A:
.a77d	5a		phy				phy
.a77e	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.a780	f0 3d		beq $a7bf			beq 	_FPUScaleExit
.a782	da		phx				phx 								; save X
.a783	e8		inx				inx
.a784	e8		inx				inx
.a785	e8		inx				inx
.a786	e8		inx				inx
.a787	e8		inx				inx
.a788	e8		inx				inx
.a789	a8		tay				tay 								; save power scalar in Y.
.a78a	a9 00		lda #$00			lda 	#0
.a78c	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.a78f	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.a792	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.a795	9d 05 03	sta $0305,x			sta 	XS_Type,x
.a798	a9 80		lda #$80			lda 	#$80
.a79a	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.a79d	a9 81		lda #$81			lda 	#$81
.a79f	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.a7a2	5a		phy				phy 								; save 10^n on stack.
.a7a3	c0 00		cpy #$00			cpy 	#0
.a7a5	10 05		bpl $a7ac			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.a7a7	98		tya				tya
.a7a8	49 ff		eor #$ff			eor 	#$FF
.a7aa	1a		inc a				inc 	a
.a7ab	a8		tay				tay
.a7ac					_FPUSAbs:
.a7ac	20 1c a7	jsr $a71c			jsr 	FPUTimes10
.a7af	88		dey				dey
.a7b0	d0 fa		bne $a7ac			bne 	_FPUSAbs 					; tos is now 10^|AC|
.a7b2	68		pla				pla 								; restore count in A
.a7b3	fa		plx				plx 								; restore X pointing to number to scale.
.a7b4	0a		asl a				asl 	a
.a7b5	b0 05		bcs $a7bc			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.a7b7	20 9b a8	jsr $a89b			jsr 	FPMultiply 					; if clear multiply.
.a7ba	80 03		bra $a7bf			bra		_FPUScaleExit
.a7bc					_FPUSDivide:
.a7bc	20 4c a9	jsr $a94c			jsr 	FPDivide
.a7bf					_FPUScaleExit:
.a7bf	7a		ply				ply
.a7c0	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: float/fpadd.asm

.a7c1					FPSubtract:
.a7c1	48		pha				pha
.a7c2	bd 0b 03	lda $030b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.a7c5	49 80		eor #$80			eor 	#$80
.a7c7	9d 0b 03	sta $030b,x			sta 	XS2_Type,x
.a7ca	68		pla				pla 								; --- and fall through ---
.a7cb					FPAdd:
.a7cb	48		pha				pha
.a7cc	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.a7cf	d0 05		bne $a7d6			bne 	_FPA_NegativeLHS
.a7d1	20 f3 a7	jsr $a7f3			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.a7d4	68		pla				pla
.a7d5	60		rts				rts
.a7d6					_FPA_NegativeLHS:
.a7d6	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.a7d9	49 80		eor #$80			eor 	#$80
.a7db	9d 05 03	sta $0305,x			sta 	XS_Type,x
.a7de	bd 0b 03	lda $030b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.a7e1	49 80		eor #$80			eor 	#$80
.a7e3	9d 0b 03	sta $030b,x			sta 	XS2_Type,x
.a7e6	20 f3 a7	jsr $a7f3			jsr 	FPAdd_Worker 				; do the add calculation.
.a7e9	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip sign of X1 back
.a7ec	49 80		eor #$80			eor 	#$80
.a7ee	9d 05 03	sta $0305,x			sta 	XS_Type,x
.a7f1	68		pla				pla
.a7f2	60		rts				rts
.a7f3					FPAdd_Worker:
.a7f3	3c 0b 03	bit $030b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.a7f6	70 08		bvs $a800			bvs 	_FPAWExit 					; no change.
.a7f8	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.a7fb	50 07		bvc $a804			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.a7fd	20 04 a6	jsr $a604			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.a800					_FPAWExit:
.a800	20 8c a6	jsr $a68c			jsr 	FPUNormalise 				; normalise the result.
.a803	60		rts				rts
.a804					_FPAWMakeSame:
.a804	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.a807	38		sec				sec
.a808	fd 0a 03	sbc $030a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.a80b	f0 1b		beq $a828			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.a80d	da		phx				phx 								; save X
.a80e	90 06		bcc $a816			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.a810	e8		inx				inx
.a811	e8		inx				inx
.a812	e8		inx				inx
.a813	e8		inx				inx
.a814	e8		inx				inx
.a815	e8		inx				inx
.a816					_FPAWShiftA:
.a816	fe 04 03	inc $0304,x			inc 	XS_Exponent,x 				; so shift exponent up.
.a819	5e 03 03	lsr $0303,x			lsr 	3+XS_Mantissa,x
.a81c	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.a81f	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.a822	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.a825	fa		plx				plx 								; restore original X
.a826	80 dc		bra $a804			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.a828					_FPAW_DoArithmetic:
.a828	3c 0b 03	bit $030b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.a82b	30 39		bmi $a866			bmi 	_FPAW_BNegative
.a82d	18		clc				clc
.a82e	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.a831	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.a834	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.a837	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.a83a	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.a83d	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.a840	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.a843	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.a846	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.a849	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.a84c	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.a84f	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.a852	90 ac		bcc $a800			bcc 	_FPAWExit 					; no carry.
.a854	fe 04 03	inc $0304,x			inc 	XS_Exponent,x 				; so shift exponent up.
.a857	38		sec				sec
.a858	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.a85b	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.a85e	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.a861	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.a864	80 9a		bra $a800			bra 	_FPAWExit
.a866					_FPAW_BNegative:
.a866	38		sec				sec
.a867	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.a86a	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.a86d	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.a870	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.a873	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.a876	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.a879	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.a87c	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.a87f	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.a882	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.a885	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.a888	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.a88b	b0 0b		bcs $a898			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.a88d	20 31 a6	jsr $a631			jsr 	FPUNegateInteger			; negate the mantissa
.a890	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip result sign
.a893	49 80		eor #$80			eor 	#$80
.a895	9d 05 03	sta $0305,x			sta 	XS_Type,x
.a898					_FPAWGoExit:
.a898	4c 00 a8	jmp $a800			jmp 	_FPAWExit

;******  Return to file: basic.asm


;******  Processing file: float/fpmultiply.asm

.a89b					FPMultiply:
.a89b	48		pha				pha
.a89c	5a		phy				phy
.a89d	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.a8a0	70 08		bvs $a8aa			bvs 	_FPM_Exit
.a8a2	3c 0b 03	bit $030b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.a8a5	50 06		bvc $a8ad			bvc 	_FPM_CalcExponent
.a8a7	20 04 a6	jsr $a604			jsr 	FPUCopyX2ToX1
.a8aa					_FPM_Exit:
.a8aa	7a		ply				ply
.a8ab	68		pla				pla
.a8ac	60		rts				rts
.a8ad					_FPM_CalcExponent:
.a8ad	18		clc				clc
.a8ae	20 1f a9	jsr $a91f			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.a8b1	9d 04 03	sta $0304,x			sta 	XS_Exponent,x 				; save the result.
.a8b4	a9 00		lda #$00			lda 	#0
.a8b6	85 16		sta $16				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.a8b8	85 17		sta $17				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.a8ba	85 18		sta $18				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.a8bc	85 19		sta $19				sta 	zLTemp1+3
.a8be	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.a8c0					_FPM_Loop:
.a8c0	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x				; check LSB of long product
.a8c3	29 01		and #$01			and 	#1
.a8c5	18		clc				clc 								; clear carry for the long rotate.
.a8c6	f0 1d		beq $a8e5			beq 	_FPM_NoAddition
.a8c8	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.a8c9	a5 16		lda $16				lda 	zLTemp1+0
.a8cb	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.a8ce	85 16		sta $16				sta 	zLTemp1+0
.a8d0	a5 17		lda $17				lda 	zLTemp1+1
.a8d2	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.a8d5	85 17		sta $17				sta 	zLTemp1+1
.a8d7	a5 18		lda $18				lda 	zLTemp1+2
.a8d9	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.a8dc	85 18		sta $18				sta 	zLTemp1+2
.a8de	a5 19		lda $19				lda 	zLTemp1+3
.a8e0	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.a8e3	85 19		sta $19				sta 	zLTemp1+3
.a8e5					_FPM_NoAddition:
.a8e5	66 19		ror $19				ror 	3+zLTemp1
.a8e7	66 18		ror $18				ror 	2+zLTemp1
.a8e9	66 17		ror $17				ror 	1+zLTemp1
.a8eb	66 16		ror $16				ror 	0+zLTemp1
.a8ed	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.a8f0	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.a8f3	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.a8f6	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.a8f9	88		dey				dey
.a8fa	d0 c4		bne $a8c0			bne 	_FPM_Loop 					; do this 32 times.
.a8fc					FPM_CopySignNormalize:
.a8fc	a5 16		lda $16				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.a8fe	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.a901	a5 17		lda $17				lda 	zLTemp1+1
.a903	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.a906	a5 18		lda $18				lda 	zLTemp1+2
.a908	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.a90b	a5 19		lda $19				lda 	zLTemp1+3
.a90d	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.a910	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; sign is xor of signs
.a913	5d 0b 03	eor $030b,x			eor 	XS2_Type,x
.a916	9d 05 03	sta $0305,x			sta 	XS_Type,x
.a919	20 8c a6	jsr $a68c			jsr 	FPUNormalise 				; normalise and exit.
.a91c	7a		ply				ply
.a91d	68		pla				pla
.a91e	60		rts				rts
.a91f					FPCalculateExponent:
.a91f	18		clc				clc
.a920	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.a923	7d 0a 03	adc $030a,x			adc 	XS2_Exponent,x
.a926	b0 08		bcs $a930			bcs 	_FPCECarry 					; carry out ?
.a928	10 03		bpl $a92d			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.a92a	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.a92c	60		rts				rts
.a92d					_FPCEExpZero:
.a92d	a9 00		lda #$00			lda 	#0
.a92f	60		rts				rts
.a930					_FPCECarry:
.a930	30 03		bmi $a935			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.a932	09 80		ora #$80			ora 	#$80 						; put in right range
.a934	60		rts				rts
.a935					_FPCEOverflow:
.a935	4c 01 a7	jmp $a701			jmp 	FP_Overflow

;******  Return to file: basic.asm


;******  Processing file: float/fpdivide.asm

.a938					FPD_IsDivZero:
.a938	20 46 ab	jsr $ab46			jsr 		ERR_Handler
>a93b	44 69 76 69 73 69 6f 6e				.text 		"Division by zero",0
>a943	20 62 79 20 7a 65 72 6f 00
.a94c					FPDivide:
.a94c	48		pha				pha
.a94d	5a		phy				phy
.a94e	3c 0b 03	bit $030b,x			bit 	XS2_Type,x 					; check if division by zero
.a951	70 e5		bvs $a938			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.a953	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.a956	f0 03		beq $a95b			beq 	_FPDCalculateExp
.a958					_FPD_Exit:
.a958	7a		ply				ply
.a959	68		pla				pla
.a95a	60		rts				rts
.a95b					_FPDCalculateExp:
.a95b	bd 0a 03	lda $030a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.a95e	49 ff		eor #$ff			eor 	#$FF
.a960	1a		inc a				inc 	a
.a961	9d 0a 03	sta $030a,x			sta 	XS2_Exponent,x
.a964	20 1f a9	jsr $a91f			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.a967	18		clc				clc 	 							; add 1 to the resulting exponent
.a968	69 01		adc #$01			adc 	#1
.a96a	b0 65		bcs $a9d1			bcs 	_FPD_Overflow 				; which can overflow.
.a96c	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.a96f	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.a971	85 16		sta $16				sta 	zLTemp1+0
.a973	85 17		sta $17				sta 	zLTemp1+1
.a975	85 18		sta $18				sta 	zLTemp1+2
.a977	85 19		sta $19				sta 	zLTemp1+3
.a979	a0 20		ldy #$20			ldy 	#32 						; times round.
.a97b					_FPD_Loop:
.a97b	38		sec				sec 								; calculate X1-X2 stacking result because we might
.a97c	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 				; not save it.
.a97f	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa,x
.a982	48		pha				pha
.a983	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.a986	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.a989	48		pha				pha
.a98a	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.a98d	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.a990	48		pha				pha
.a991	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.a994	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.a997	90 17		bcc $a9b0			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.a999	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x 			; save results out to A
.a99c	68		pla				pla
.a99d	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.a9a0	68		pla				pla
.a9a1	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.a9a4	68		pla				pla
.a9a5	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.a9a8	a5 19		lda $19				lda 	zLTemp1+3 					; set high bit of result
.a9aa	09 80		ora #$80			ora 	#$80
.a9ac	85 19		sta $19				sta 	zLTemp1+3
.a9ae	80 03		bra $a9b3			bra 	_FPD_Rotates
.a9b0					_FPD_NoSubtract:
.a9b0	68		pla				pla 								; throw away unwanted results
.a9b1	68		pla				pla
.a9b2	68		pla				pla
.a9b3					_FPD_Rotates:
.a9b3	5e 09 03	lsr $0309,x			lsr 	3+XS2_Mantissa,x
.a9b6	7e 08 03	ror $0308,x			ror 	2+XS2_Mantissa,x
.a9b9	7e 07 03	ror $0307,x			ror 	1+XS2_Mantissa,x
.a9bc	7e 06 03	ror $0306,x			ror 	0+XS2_Mantissa,x
.a9bf	06 16		asl $16				asl 	zLTemp1 					; rotate result round left
.a9c1	26 17		rol $17				rol 	zLTemp1+1
.a9c3	26 18		rol $18				rol 	zLTemp1+2
.a9c5	26 19		rol $19				rol 	zLTemp1+3
.a9c7	90 02		bcc $a9cb			bcc 	_FPD_NoCarry
.a9c9	e6 16		inc $16				inc 	zLTemp1 					; if rotated out, set LSB.
.a9cb					_FPD_NoCarry:
.a9cb	88		dey				dey 								; do 32 times
.a9cc	d0 ad		bne $a97b			bne 	_FPD_Loop
.a9ce	4c fc a8	jmp $a8fc			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.a9d1					_FPD_Overflow:
.a9d1	4c 01 a7	jmp $a701			jmp 	FP_Overflow

;******  Return to file: basic.asm


;******  Processing file: float/fpcompare.asm

.a9d4					FPCompare:
.a9d4	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.a9d7	48		pha				pha
.a9d8	bd 0a 03	lda $030a,x			lda 	XS2_Exponent,x
.a9db	48		pha				pha
.a9dc	20 c1 a7	jsr $a7c1			jsr 	FPSubtract 					; calculate X1-X2
.a9df	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.a9e2	70 2c		bvs $aa10			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.a9e4	68		pla				pla
.a9e5	8d 2d 04	sta $042d			sta 	ExpTemp						; save first exponent in temporary reg.
.a9e8	68		pla				pla
.a9e9	38		sec				sec
.a9ea	ed 2d 04	sbc $042d			sbc 	ExpTemp 					; calculate AX-BX
.a9ed	70 15		bvs $aa04			bvs 	_FPCNotEqual				; overflow, can't be equal.
.a9ef	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.a9f0	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.a9f2	b0 10		bcs $aa04			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.a9f4	38		sec				sec
.a9f5	ad 2d 04	lda $042d			lda 	ExpTemp 					; get one of the exponents back.
.a9f8	e9 18		sbc #$18			sbc 	#24 						; allow for 2^24 error, relatively.
.a9fa	b0 02		bcs $a9fe			bcs 	_FPCNotRange 				; keep in range.
.a9fc	a9 01		lda #$01			lda 	#1
.a9fe					_FPCNotRange:
.a9fe	38		sec				sec
.a9ff	fd 04 03	sbc $0304,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.aa02	b0 0e		bcs $aa12			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.aa04					_FPCNotEqual:
.aa04	bd 05 03	lda $0305,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.aa07	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.aa09	f0 02		beq $aa0d			beq 	_FPCNE2
.aa0b	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.aa0d	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.aa0e	80 04		bra $aa14			bra 	_FPCExit
.aa10					_FPCPullZero:
.aa10	68		pla				pla 								; throw saved exponents
.aa11	68		pla				pla
.aa12					_FPCZero:
.aa12	a9 00		lda #$00			lda 	#0 							; and return zero
.aa14					_FPCExit:
.aa14	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: float/fpparts.asm

.aa15					FPFractionalPart:
.aa15	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.aa18	38		sec				sec 								; this flag tells us to keep the fractional part
.aa19	30 0f		bmi $aa2a			bmi 	FPGetPart
.aa1b	60		rts				rts
.aa1c					FPIntegerPart:
.aa1c	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.aa1f	18		clc				clc 								; this flag says keep the integer part.
.aa20	30 08		bmi $aa2a			bmi 	FPGetPart 					; -ve exponents are 0..127
.aa22	48		pha				pha
.aa23	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.aa25	9d 05 03	sta $0305,x			sta 	XS_Type,x
.aa28	68		pla				pla
.aa29	60		rts				rts
.aa2a					FPGetPart:
.aa2a	48		pha				pha
.aa2b	5a		phy				phy 								; save Y
.aa2c	08		php				php 								; save action
.aa2d	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.aa30	70 62		bvs $aa94			bvs 	_FPGP_Exit 					; then do nothing.
.aa32	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.aa34	85 16		sta $16				sta 	zLTemp1+0 					; this mask is applied to chop out the
.aa36	85 17		sta $17				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.aa38	85 18		sta $18				sta 	zLTemp1+2
.aa3a	85 19		sta $19				sta 	zLTemp1+3
.aa3c	bd 04 03	lda $0304,x			lda 	XS_Exponent,x				; the number of shifts.
.aa3f	38		sec				sec
.aa40	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.aa42	f0 12		beq $aa56			beq 	_FPGP_NoShift 				; ... if any
.aa44	c9 20		cmp #$20			cmp 	#32
.aa46	90 02		bcc $aa4a			bcc 	_FPGP_NotMax
.aa48	a9 20		lda #$20			lda 	#32 						; max of 32.
.aa4a					_FPGP_NotMax:
.aa4a	a8		tay				tay 								; Y is the mask shift count.
.aa4b					_FPGP_ShiftMask:
.aa4b	46 19		lsr $19				lsr 	3+zLTemp1
.aa4d	66 18		ror $18				ror 	2+zLTemp1
.aa4f	66 17		ror $17				ror 	1+zLTemp1
.aa51	66 16		ror $16				ror 	0+zLTemp1
.aa53	88		dey				dey
.aa54	d0 f5		bne $aa4b			bne 	_FPGP_ShiftMask
.aa56					_FPGP_NoShift:
.aa56	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.aa58	8e 2d 04	stx $042d			stx 	ExpTemp						; save X
.aa5b					_FPGP_MaskLoop:
.aa5b	b9 16 00	lda $0016,y			lda 	zlTemp1,y 					; get mask byte
.aa5e	28		plp				plp 								; if CC we keep the top part, so we
.aa5f	08		php				php		 							; flip the mask.
.aa60	b0 02		bcs $aa64			bcs		_FPGP_NoFlip
.aa62	49 ff		eor #$ff			eor 	#$FF
.aa64					_FPGP_NoFlip:
.aa64	3d 00 03	and $0300,x			and 	XS_Mantissa,x 				; and into the mantissa.
.aa67	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.aa6a	e8		inx				inx
.aa6b	c8		iny				iny
.aa6c	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.aa6e	d0 eb		bne $aa5b			bne 	_FPGP_MaskLoop
.aa70	ae 2d 04	ldx $042d			ldx 	ExpTemp						; restore X
.aa73	28		plp				plp
.aa74	08		php				php 								; get action flag on the stack
.aa75	90 05		bcc $aa7c			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.aa77	a9 00		lda #$00			lda 	#0
.aa79	9d 05 03	sta $0305,x			sta 	XS_Type,x
.aa7c					_FPGP_NotFractional:
.aa7c	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 						; check if \1 zero
.aa7f	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.aa82	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.aa85	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.aa88	f0 05		beq $aa8f			beq 	_FPGP_Zero 					; if zero, return zero
.aa8a	20 8c a6	jsr $a68c			jsr 	FPUNormalise
.aa8d	80 05		bra $aa94			bra 	_FPGP_Exit 					; and exit
.aa8f					_FPGP_Zero:
.aa8f	a9 40		lda #$40			lda 	#$40 						; set zero flag
.aa91	9d 05 03	sta $0305,x			sta 	XS_Type,x
.aa94					_FPGP_Exit:
.aa94	68		pla				pla 								; throw saved action flag.
.aa95	7a		ply				ply
.aa96	68		pla				pla
.aa97	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: float/fpfromstr.asm

.aa98					FPFromString:
.aa98	48		pha				pha 								; push A
.aa99	b1 1a		lda ($1a),y			lda		(zGenPtr),y					; is it followed by a DP ?
.aa9b	c9 2e		cmp #$2e			cmp 	#"."
.aa9d	f0 03		beq $aaa2			beq	 	_FPFIsDecimal
.aa9f	4c 05 ab	jmp $ab05			jmp 	_FPFNotDecimal
.aaa2					_FPFIsDecimal:
.aaa2	c8		iny				iny 								; consume the decimal.
.aaa3	20 55 a6	jsr $a655			jsr 	FPUToFloat 					; convert the integer to float.
.aaa6	da		phx				phx 								; save X.
.aaa7	5a		phy				phy 								; save decimal start position
.aaa8	e8		inx				inx
.aaa9	e8		inx				inx
.aaaa	e8		inx				inx
.aaab	e8		inx				inx
.aaac	e8		inx				inx
.aaad	e8		inx				inx
.aaae	20 5e a5	jsr $a55e			jsr 	INTFromStringY 				; get the part after the DP.
.aab1	20 55 a6	jsr $a655			jsr 	FPUToFloat 					; convert that to a float.
.aab4	68		pla				pla 								; calculate - chars consumed.
.aab5	8c 2d 04	sty $042d			sty 	ExpTemp
.aab8	38		sec				sec
.aab9	ed 2d 04	sbc $042d			sbc 	ExpTemp 					; this is the shift amount
.aabc	20 7d a7	jsr $a77d			jsr 	FPUScale10A 				; scale it by 10^AC
.aabf	fa		plx				plx 								; restore original X
.aac0	20 cb a7	jsr $a7cb			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.aac3	b1 1a		lda ($1a),y			lda 	(zGenPtr),y 				; exponent ?
.aac5	c9 45		cmp #$45			cmp 	#"E"
.aac7	f0 04		beq $aacd			beq 	_FPFExponent
.aac9	c9 65		cmp #$65			cmp 	#"e"
.aacb	d0 38		bne $ab05			bne 	_FPFNotDecimal 				; no, then exit normally.
.aacd					_FPFExponent:
.aacd	c8		iny				iny 								; skip over E symbol.
.aace	b1 1a		lda ($1a),y			lda 	(zGenPtr),y 				; look at next
.aad0	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.aad2	d0 01		bne $aad5			bne 	_FPFGotSign
.aad4	c8		iny				iny 								; if it was - skip over it.
.aad5					_FPFGotSign:
.aad5	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.aad6	da		phx				phx
.aad7	e8		inx				inx
.aad8	e8		inx				inx
.aad9	e8		inx				inx
.aada	e8		inx				inx
.aadb	e8		inx				inx
.aadc	e8		inx				inx
.aadd	20 5e a5	jsr $a55e			jsr 	INTFromStringY 				; get the exponent
.aae0	fa		plx				plx 								; restore X.
.aae1	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.aae4	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.aae7	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.aaea	d0 1b		bne $ab07			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.aaec	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.aaef	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.aaf1	b0 14		bcs $ab07			bcs 	_FPFXOverflow
.aaf3	68		pla				pla 								; get direction
.aaf4	d0 09		bne $aaff			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.aaf6	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.aaf9	49 ff		eor #$ff			eor 	#$FF
.aafb	1a		inc a				inc 	a
.aafc	9d 06 03	sta $0306,x			sta 	XS2_Mantissa+0,x
.aaff					_FPFXScale:
.aaff	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.ab02	20 7d a7	jsr $a77d			jsr 	FPUScale10A 				; scale by the exponent.
.ab05					_FPFNotDecimal:
.ab05	68		pla				pla
.ab06	60		rts				rts
.ab07					_FPFXOverflow:
.ab07	20 46 ab	jsr $ab46			jsr 	ERR_Handler
>ab0a	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>ab12	20 52 61 6e 67 65 00

;******  Return to file: basic.asm

.ab19					StartROM:
.ab19	a2 ff		ldx #$ff			ldx 	#$FF 						; empty stack
.ab1b	9a		txs				txs
.ab1c	20 00 a0	jsr $a000			jsr 	IF_Reset 					; reset external interface
.ab1f	20 4a a0	jsr $a04a			jsr 	IFT_ClearScreen
.ab22	20 e2 a3	jsr $a3e2			jsr 	FPTTest
.ab25	a2 06		ldx #$06			ldx 	#6
.ab27	a9 3a		lda #$3a			lda 	#Source & $FF
.ab29	85 1a		sta $1a				sta 	zGenPtr
.ab2b	a9 ab		lda #$ab			lda 	#Source >> 8
.ab2d	85 1b		sta $1b				sta 	zGenPtr+1
.ab2f	20 59 a5	jsr $a559			jsr 	IntFromString
.ab32	b0 fe		bcs $ab32	x1:		bcs 	x1
.ab34	20 98 aa	jsr $aa98			jsr 	FPFromString
>ab37	5c						.byte 	$5C
.ab38	80 fe		bra $ab38	freeze:	bra 	freeze
>ab3a	31 2e 32 33 34 36 37 38		Source:	.text 	"1.234678e-3",0
>ab42	65 2d 33 00
.ab46					ERR_Handler:
.ab46	80 fe		bra $ab46			bra 	ERR_Handler
.ab48					NMIHandler:
.ab48	40		rti				rti
>fffa	48 ab						.word	NMIHandler
>fffc	19 ab						.word 	StartROM
>fffe	5d a3						.word 	TIM_BreakVector

;******  End of listing
