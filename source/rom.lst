
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -D CPU=6502 -D INTERFACE=1 -b -L rom.lst -o rom.bin basic.asm
; Thu Aug 15 13:32:06 2019

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=6502					CPU=6502
=1					INTERFACE=1

;******  Processing input file: basic.asm

.0000	ea		nop				nop

;******  Processing file: data.asm

>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zLTemp1:	.dword ?						; long word (used in multiply)
>001a					zGenPtr:	.word ? 						; general pointer.
>0300					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0304					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0305					XS_Type 	.byte ? 						; bit 7 sign (float only)
=774					XS2_Mantissa = XS_Mantissa+6
=778					XS2_Exponent = XS_Exponent+6
=779					XS2_Type = XS_Type+6
>0400					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>0402					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>0404					Tim_SR:		.byte ? 						; Processor Status
>0405					Tim_A:		.byte ? 						; Processor Registers
>0406					Tim_X:		.byte ?
>0407					Tim_Y:		.byte ?
>0408					Tim_Z:		.byte ?
>0409					Tim_SP:		.byte ?							; Stack Pointer
>040a					ExpTemp:	.byte ?							; Working temp for exponents.

;******  Return to file: basic.asm


;******  Processing file: interface/interface_emu.asm

=80					IF_Width 	= 80 							; characters across
=25					IF_Height 	= 25 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=6					IF_XPos 	= 6 							; current position, horizontal.
=$8000					IF_Screen = $8000							; 2k screen RAM here
=$8800					IF_PKeyboard = $8800						; Keyboard port.
=$8801					IF_PBreak = $8801 							; Break key.
.a000					IF_Reset:
.a000	60		rts				rts
.a001					IF_Home:
.a001	48		pha				pha
.a002	a9 00		lda #$00			lda 	#0	 						; zero X position
.a004	85 06		sta $06				sta 	IF_XPos
.a006	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.a008	85 04		sta $04				sta 	IF_Pos
.a00a	a9 80		lda #$80			lda 	#IF_Screen >> 8
.a00c	85 05		sta $05				sta 	IF_Pos+1
.a00e	68		pla				pla
.a00f	60		rts				rts
.a010					IF_NewLine:
.a010	48		pha				pha
.a011	a9 00		lda #$00			lda 	#0 							; back to start of line
.a013	85 06		sta $06				sta 	IF_XPos
.a015	18		clc				clc 								; down one line
.a016	a5 04		lda $04				lda 	IF_Pos
.a018	69 50		adc #$50			adc 	#80
.a01a	85 04		sta $04				sta 	IF_Pos
.a01c	90 02		bcc $a020			bcc 	_IF_NoCarry 				; carry through.
.a01e	e6 05		inc $05				inc 	IF_Pos+1
.a020					_IF_NoCarry:
.a020	68		pla				pla
.a021	60		rts				rts
.a022					IF_Read:
.a022	5a		phy				phy 								; save current Y
.a023	a4 06		ldy $06				ldy 	IF_XPos 					; read character at current position
.a025	b1 04		lda ($04),y			lda 	(IF_Pos),y
.a027	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a029	7a		ply				ply									; restore Y
.a02a	60		rts				rts
.a02b					IF_Write:
.a02b	5a		phy				phy 								; save current Y
.a02c	a4 06		ldy $06				ldy 	IF_XPos 					; write character at current position
.a02e	91 04		sta ($04),y			sta 	(IF_Pos),y
.a030	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a032	7a		ply				ply									; restore Y
.a033	60		rts				rts
.a034					IF_LeftOne:
.a034	c6 06		dec $06				dec 	IF_XPos
.a036	60		rts				rts
.a037					IF_CheckBreak:
.a037	ad 01 88	lda $8801			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.a03a	60		rts				rts
.a03b					IF_GetKey:
.a03b	ad 00 88	lda $8800			lda 	IF_PKeyboard				; read keyboard
.a03e	f0 07		beq $a047			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.a040	48		pha				pha 								; key pressed, clear queue.
.a041	a9 00		lda #$00			lda 	#0
.a043	8d 00 88	sta $8800			sta 	IF_PKeyboard
.a046	68		pla				pla
.a047					_IFGK_NoKey:
.a047	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.a049	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: interface/interface_tools.asm

=$200					IFT_XCursor = $200								; current logical position on screen
=$201					IFT_YCursor = $201
=$202					IFT_Buffer = $202 								; scroll copy buffer.
=$280					IFT_LineBuffer = $280 							; line input buffer.
.a04a					IFT_ClearScreen:
.a04a	48		pha				pha
.a04b	da		phx				phx
.a04c	5a		phy				phy
.a04d	20 01 a0	jsr $a001			jsr 	IF_Home 					; home cursor
.a050	a2 19		ldx #$19			ldx 	#IF_Height 					; this many lines.
.a052					_IFT_CS0:
.a052	a0 50		ldy #$50			ldy 	#IF_Width 					; this many chars/line
.a054					_IFT_CS1:
.a054	a9 20		lda #$20			lda 	#' '						; clear line.
.a056	20 2b a0	jsr $a02b			jsr 	IF_Write
.a059	88		dey				dey
.a05a	d0 f8		bne $a054			bne 	_IFT_CS1
.a05c	20 10 a0	jsr $a010			jsr 	IF_NewLine 					; next line down
.a05f	ca		dex				dex
.a060	d0 f0		bne $a052			bne 	_IFT_CS0
.a062	7a		ply				ply
.a063	fa		plx				plx
.a064	68		pla				pla
.a065					IFT_HomeCursor:
.a065	48		pha				pha
.a066	20 01 a0	jsr $a001			jsr 	IF_Home
.a069	a9 00		lda #$00			lda 	#0
.a06b	8d 00 02	sta $0200			sta 	IFT_XCursor
.a06e	8d 01 02	sta $0201			sta 	IFT_YCursor
.a071	68		pla				pla
.a072	60		rts				rts
.a073					IFT_UpLine:
.a073	48		pha				pha
.a074	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.a077	3a		dec a				dec 	a 							; line above
.a078	30 03		bmi $a07d			bmi 	_IFTULExit 					; too far, abort
.a07a	20 0a a1	jsr $a10a			jsr 	IFT_SetYPos					; set to that line.
.a07d					_IFTULExit:
.a07d	68		pla				pla
.a07e	60		rts				rts
.a07f					IFT_PrintCharacter:
.a07f	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.a081	f0 18		beq $a09b			beq 	IFT_NewLine
.a083	48		pha				pha
.a084	20 b3 a0	jsr $a0b3			jsr 	IFT_UpperCase 				; make upper case
.a087	29 3f		and #$3f			and 	#63 						; make 6 bit PETSCII
.a089	20 2b a0	jsr $a02b			jsr 	IF_Write 					; write out.
.a08c	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.a08f	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.a092	c9 50		cmp #$50			cmp 	#IF_Width
.a094	d0 03		bne $a099			bne 	_IFT_PCNotEOL
.a096	20 9b a0	jsr $a09b			jsr 	IFT_NewLine 				; if so do new line.
.a099					_IFT_PCNotEOL:
.a099	68		pla				pla
.a09a	60		rts				rts
.a09b					IFT_NewLine:
.a09b	48		pha				pha
.a09c	20 10 a0	jsr $a010			jsr 	IF_NewLine 					; new line on actual screen.
.a09f	a9 00		lda #$00			lda 	#0 							; reset x position
.a0a1	8d 00 02	sta $0200			sta 	IFT_XCursor
.a0a4	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.a0a7	ad 01 02	lda $0201			lda 	IFT_YCursor
.a0aa	c9 19		cmp #$19			cmp 	#IF_Height 					; reached bottom.
.a0ac	d0 03		bne $a0b1			bne 	_IFT_NL_NotEOS
.a0ae	20 be a0	jsr $a0be			jsr 	IFT_Scroll 					; scroll screen up.
.a0b1					_IFT_NL_NotEOS:
.a0b1	68		pla				pla
.a0b2	60		rts				rts
.a0b3					IFT_UpperCase:
.a0b3	c9 61		cmp #$61			cmp 	#"a"
.a0b5	90 06		bcc $a0bd			bcc 	_IFT_UCExit
.a0b7	c9 7b		cmp #$7b			cmp 	#"z"+1
.a0b9	b0 02		bcs $a0bd			bcs 	_IFT_UCExit
.a0bb	49 20		eor #$20			eor 	#$20
.a0bd					_IFT_UCExit:
.a0bd	60		rts				rts
.a0be					IFT_Scroll:
.a0be	48		pha				pha 								; save AXY
.a0bf	da		phx				phx
.a0c0	5a		phy				phy
.a0c1	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.a0c3					_IFT_SLoop:
.a0c3	20 e3 a0	jsr $a0e3			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.a0c6	e8		inx				inx
.a0c7	e0 18		cpx #$18			cpx 	#IF_Height-1				; do whole screen
.a0c9	d0 f8		bne $a0c3			bne 	_IFT_SLoop
.a0cb	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a0cd	20 0a a1	jsr $a10a			jsr 	IFT_SetYPos
.a0d0	a2 50		ldx #$50			ldx 	#IF_Width 					; blank line
.a0d2					_IFT_SBlank:
.a0d2	a9 20		lda #$20			lda 	#32
.a0d4	20 2b a0	jsr $a02b			jsr 	IF_Write
.a0d7	ca		dex				dex
.a0d8	d0 f8		bne $a0d2			bne 	_IFT_SBlank
.a0da	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a0dc	20 0a a1	jsr $a10a			jsr 	IFT_SetYPos
.a0df	7a		ply				ply
.a0e0	fa		plx				plx
.a0e1	68		pla				pla
.a0e2	60		rts				rts
.a0e3					_IFT_ScrollLine:
.a0e3	da		phx				phx
.a0e4	da		phx				phx
.a0e5	8a		txa				txa 								; copy line into buffer.
.a0e6	1a		inc a				inc 	a 							; next line down.
.a0e7	20 0a a1	jsr $a10a			jsr 	IFT_SetYPos
.a0ea	a2 00		ldx #$00			ldx 	#0
.a0ec					_IFTScrollCopy1:
.a0ec	20 22 a0	jsr $a022			jsr 	IF_Read
.a0ef	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.a0f2	e8		inx				inx
.a0f3	e0 50		cpx #$50			cpx 	#IF_Width
.a0f5	d0 f5		bne $a0ec			bne 	_IFTScrollCopy1
.a0f7	68		pla				pla
.a0f8	20 0a a1	jsr $a10a			jsr 	IFT_SetYPos
.a0fb	a2 00		ldx #$00			ldx 	#0
.a0fd					_IFTScrollCopy2:
.a0fd	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.a100	20 2b a0	jsr $a02b			jsr 	IF_Write
.a103	e8		inx				inx
.a104	e0 50		cpx #$50			cpx 	#IF_Width
.a106	d0 f5		bne $a0fd			bne 	_IFTScrollCopy2
.a108	fa		plx				plx
.a109	60		rts				rts
.a10a					IFT_SetYPos:
.a10a	48		pha				pha
.a10b	da		phx				phx
.a10c	aa		tax				tax
.a10d	20 65 a0	jsr $a065			jsr 	IFT_HomeCursor
.a110	e0 00		cpx #$00			cpx 	#0
.a112	f0 09		beq $a11d			beq 	_IFT_MOAExit
.a114					_IFT_MOALoop:
.a114	20 10 a0	jsr $a010			jsr 	IF_NewLine
.a117	ee 01 02	inc $0201			inc 	IFT_YCursor
.a11a	ca		dex				dex
.a11b	d0 f7		bne $a114			bne		_IFT_MOALoop
.a11d					_IFT_MOAExit:
.a11d	fa		plx				plx
.a11e	68		pla				pla
.a11f	60		rts				rts
.a120					IFT_GetKeyCursor:
.a120	20 28 a1	jsr $a128			jsr 	_IFT_FlipCursor 			; reverse current
.a123					_IFT_GKCWait:
.a123	20 3b a0	jsr $a03b			jsr 	IF_GetKey 					; get key
.a126	f0 fb		beq $a123			beq 	_IFT_GKCWait
.a128					_IFT_FlipCursor:
.a128	48		pha				pha 								; save
.a129	20 22 a0	jsr $a022			jsr 	IF_Read 					; read
.a12c	20 34 a0	jsr $a034			jsr 	IF_LeftOne
.a12f	49 80		eor #$80			eor 	#$80 						; reverse
.a131	20 2b a0	jsr $a02b			jsr 	IF_Write 					; write
.a134	20 34 a0	jsr $a034			jsr 	IF_LeftOne
.a137	68		pla				pla
.a138	60		rts				rts
.a139					IFT_ReadLine:
.a139	48		pha				pha
.a13a					_IFT_RLLoop:
.a13a	20 20 a1	jsr $a120			jsr 	IFT_GetKeyCursor 			; get keystroke
.a13d	c9 0d		cmp #$0d			cmp 	#13							; return
.a13f	f0 7d		beq $a1be			beq 	_IFT_RLExit
.a141	c9 20		cmp #$20			cmp 	#32 						; control character
.a143	90 05		bcc $a14a			bcc 	_IFT_Control
.a145	20 7f a0	jsr $a07f			jsr 	IFT_PrintCharacter
.a148	80 f0		bra $a13a			bra 	_IFT_RLLoop
.a14a					_IFT_Control:
.a14a	c9 01		cmp #$01			cmp 	#"A"-64
.a14c	f0 26		beq $a174			beq 	_IFT_Left
.a14e	c9 04		cmp #$04			cmp 	#"D"-64
.a150	f0 2e		beq $a180			beq 	_IFT_Right
.a152	c9 17		cmp #$17			cmp 	#"W"-64
.a154	f0 36		beq $a18c			beq 	_IFT_Up
.a156	c9 13		cmp #$13			cmp 	#"S"-64
.a158	f0 3e		beq $a198			beq 	_IFT_Down
.a15a	c9 08		cmp #$08			cmp 	#"H"-64
.a15c	f0 09		beq $a167			beq 	_IFT_Backspace
.a15e	c9 1a		cmp #$1a			cmp 	#"Z"-64
.a160	d0 d8		bne $a13a			bne 	_IFT_RLLoop
.a162	20 4a a0	jsr $a04a			jsr 	IFT_ClearScreen				; clear CTL-Z
.a165	80 d3		bra $a13a			bra 	_IFT_RLLoop
.a167					_IFT_Backspace:
.a167	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.a16a	f0 ce		beq $a13a			beq 	_IFT_RLLoop
.a16c	20 34 a0	jsr $a034			jsr 	IF_LeftOne
.a16f	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.a171	20 2b a0	jsr $a02b			jsr 	IF_Write
.a174					_IFT_Left:
.a174	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.a177	10 29		bpl $a1a2			bpl 	_IFT_Reposition
.a179	a9 4f		lda #$4f			lda 	#IF_Width-1
.a17b					_IFT_SetX:
.a17b	8d 00 02	sta $0200			sta 	IFT_XCursor
.a17e	80 22		bra $a1a2			bra 	_IFT_Reposition
.a180					_IFT_Right:
.a180	ee 00 02	inc $0200			inc 	IFT_XCursor
.a183	ad 00 02	lda $0200			lda 	IFT_XCursor
.a186	49 50		eor #$50			eor 	#IF_Width
.a188	f0 f1		beq $a17b			beq 	_IFT_SetX
.a18a	80 16		bra $a1a2			bra 	_IFT_Reposition
.a18c					_IFT_Up:
.a18c	ce 01 02	dec $0201			dec 	IFT_YCursor
.a18f	10 11		bpl $a1a2			bpl 	_IFT_Reposition
.a191	a9 18		lda #$18			lda 	#IF_Height-1
.a193					_IFT_SetY:
.a193	8d 01 02	sta $0201			sta 	IFT_YCursor
.a196	80 0a		bra $a1a2			bra 	_IFT_Reposition
.a198					_IFT_Down:
.a198	ee 01 02	inc $0201			inc 	IFT_YCursor
.a19b	ad 01 02	lda $0201			lda 	IFT_YCursor
.a19e	49 19		eor #$19			eor 	#IF_Height
.a1a0	f0 f1		beq $a193			beq 	_IFT_SetY
.a1a2					_IFT_Reposition:
.a1a2	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.a1a5	48		pha				pha
.a1a6	ad 01 02	lda $0201			lda 	IFT_YCursor
.a1a9	20 0a a1	jsr $a10a			jsr 	IFT_SetYPos
.a1ac	68		pla				pla
.a1ad	aa		tax				tax
.a1ae	e0 00		cpx #$00			cpx 	#0
.a1b0	f0 88		beq $a13a			beq 	_IFT_RLLoop
.a1b2					_IFT_MoveRight:
.a1b2	20 22 a0	jsr $a022			jsr 	IF_Read
.a1b5	ee 00 02	inc $0200			inc 	IFT_XCursor
.a1b8	ca		dex				dex
.a1b9	d0 f7		bne $a1b2			bne 	_IFT_MoveRight
.a1bb	4c 3a a1	jmp $a13a			jmp 	_IFT_RLLoop
.a1be					_IFT_RLExit:
.a1be	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.a1c1	20 0a a1	jsr $a10a			jsr 	IFT_SetYPos
.a1c4	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.a1c6					_IFT_RLRead:
.a1c6	20 22 a0	jsr $a022			jsr 	IF_Read
.a1c9	18		clc				clc 								; convert back to ASCII.
.a1ca	49 20		eor #$20			eor 	#$20
.a1cc	69 20		adc #$20			adc 	#$20
.a1ce	9d 80 02	sta $0280,x			sta 	IFT_LineBuffer,x
.a1d1	e8		inx				inx
.a1d2	e0 50		cpx #$50			cpx 	#IF_Width
.a1d4	d0 f0		bne $a1c6			bne 	_IFT_RLRead
.a1d6					_IFT_RL_Trim:
.a1d6	ca		dex				dex 	 							; previous char
.a1d7	30 07		bmi $a1e0			bmi 	_IFT_Found 					; gone too far
.a1d9	bd 80 02	lda $0280,x			lda 	IFT_LineBuffer,x			; go back if space
.a1dc	c9 20		cmp #$20			cmp 	#" "
.a1de	f0 f6		beq $a1d6			beq 	_IFT_RL_Trim
.a1e0					_IFT_Found:
.a1e0	e8		inx				inx 								; forward to non-space
.a1e1	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.a1e3	9d 80 02	sta $0280,x			sta 	IFT_LineBuffer,x
.a1e6	68		pla				pla
.a1e7	a2 80		ldx #$80			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.a1e9	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.a1eb	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: utility/tim.asm

.a1ec					TIM_Error:
.a1ec	20 73 a0	jsr $a073			jsr 	IFT_UpLine 					; go up one line.
.a1ef	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.a1f1	80 02		bra $a1f5			bra 	TIM_ShowPrompt
.a1f3					TIM_NewCommand:
.a1f3	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.a1f5					TIM_ShowPrompt:
.a1f5	20 7f a0	jsr $a07f			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.a1f8	20 39 a1	jsr $a139			jsr 	IFT_ReadLine	 			; get character, go to next line
.a1fb	20 9b a0	jsr $a09b			jsr 	IFT_NewLine					; go to next line.
.a1fe	86 10		stx $10				stx 	zTemp1 						; save line read address
.a200	84 11		sty $11				sty 	zTemp1+1
.a202	a0 01		ldy #$01			ldy 	#1 							; get first character after the prompt.
.a204	b1 10		lda ($10),y			lda 	(zTemp1),y
.a206	c9 52		cmp #$52			cmp 	#"R"						; show registers
.a208	f0 6b		beq $a275			beq 	TIM_ShowRegisters
.a20a	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.a20c	f0 12		beq $a220			beq 	TIM_ShowMemory
.a20e	c9 47		cmp #$47			cmp 	#"G"						; execute
.a210	f0 49		beq $a25b			beq 	TIM_Execute
.a212	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.a214	f0 07		beq $a21d			beq 	TIM_GoLoadMemory
.a216	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.a218	d0 d2		bne $a1ec			bne 	TIM_Error
.a21a	4c 96 a3	jmp $a396			jmp 	TIM_UpdateRegisters
.a21d					TIM_GoLoadMemory:
.a21d	4c c1 a3	jmp $a3c1			jmp 	TIM_LoadMemory
.a220					TIM_ShowMemory:
.a220	20 12 a3	jsr $a312			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.a223	b0 c7		bcs $a1ec			bcs 	TIM_Error
.a225	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.a227	85 12		sta $12				sta 	zTemp2
.a229	a5 15		lda $15				lda 	zTemp3+1
.a22b	85 13		sta $13				sta 	zTemp2+1
.a22d	20 12 a3	jsr $a312			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.a230	90 08		bcc $a23a			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.a232	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.a234	85 14		sta $14				sta 	zTemp3
.a236	a5 13		lda $13				lda 	zTemp2+1
.a238	85 15		sta $15				sta 	zTemp3+1
.a23a					_TIMSM_Start:
.a23a	20 ea a2	jsr $a2ea			jsr 	TIM_WriteLine 				; write one line of hex out
.a23d	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.a23f	18		clc				clc
.a240	69 10		adc #$10			adc 	#16
.a242	85 12		sta $12				sta 	zTemp2
.a244	90 02		bcc $a248			bcc 	_TIMSM_NoCarry
.a246	e6 13		inc $13				inc 	zTemp2+1
.a248					_TIMSM_NoCarry:
.a248	20 37 a0	jsr $a037			jsr 	IF_CheckBreak 				; check CTL+C
.a24b	d0 0b		bne $a258			bne 	_TIMSM_Ends 				; if pressed break out.
.a24d	38		sec				sec 								; check past the end address in zTemp3
.a24e	a5 14		lda $14				lda 	zTemp3
.a250	e5 12		sbc $12				sbc 	zTemp2
.a252	a5 15		lda $15				lda 	zTemp3+1
.a254	e5 13		sbc $13				sbc 	zTemp2+1
.a256	10 e2		bpl $a23a			bpl 	_TIMSM_Start
.a258					_TIMSM_Ends:
.a258	4c f3 a1	jmp $a1f3			jmp 	TIM_NewCommand
.a25b					TIM_Execute:
.a25b	20 12 a3	jsr $a312			jsr 	TIM_GetHex 					; get the execute address
.a25e	b0 8c		bcs $a1ec			bcs 	TIM_Error 					; not legitimate
.a260	ae 09 04	ldx $0409			ldx 	TIM_SP 						; set up SP
.a263	9a		txs				txs
.a264	ad 04 04	lda $0404			lda 	TIM_SR 						; Status for PLP
.a267	48		pha				pha
.a268	ad 05 04	lda $0405			lda 	TIM_A 						; restore AXYZ
.a26b	ae 06 04	ldx $0406			ldx 	TIM_X
.a26e	ac 07 04	ldy $0407			ldy 	TIM_Y
.a271	28		plp				plp 								; and PS Byte.
.a272	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.a275					TIM_Start:
.a275					TIM_ShowRegisters:
.a275	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.a278	8d 03 04	sta $0403			sta 	TIM_IRQ+1
.a27b	ad ff ff	lda $ffff			lda 	$FFFF
.a27e	8d 02 04	sta $0402			sta 	TIM_IRQ
.a281	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.a283					_TIMSR_Text:
.a283	bd ae a2	lda $a2ae,x			lda 	_TIMSR_Label,x
.a286	20 7f a0	jsr $a07f			jsr 	IFT_PrintCharacter
.a289	e8		inx				inx
.a28a	e0 23		cpx #$23			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.a28c	d0 f5		bne $a283			bne 	_TIMSR_Text
.a28e	a2 00		ldx #$00			ldx 	#0 							; output Register Line.
.a290					_TIMSR_LoopSpace:
.a290	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.a292	b0 04		bcs $a298			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.a294	8a		txa				txa
.a295	4a		lsr a				lsr 	a
.a296	b0 05		bcs $a29d			bcs 	_TIMSR_NoSpace
.a298					_TIMSR_Space:
.a298	a9 20		lda #$20			lda 	#" "
.a29a	20 7f a0	jsr $a07f			jsr 	IFT_PrintCharacter
.a29d					_TIMSR_NoSpace:
.a29d	bd 00 04	lda $0400,x			lda 	TIM_PC,x 					; output hex value.
.a2a0	20 d1 a2	jsr $a2d1			jsr 	TIM_WriteHex
.a2a3	e8		inx				inx
.a2a4	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.a2a6	d0 e8		bne $a290			bne 	_TimSR_LoopSpace
.a2a8	20 9b a0	jsr $a09b			jsr 	IFT_NewLine 				; new line
.a2ab	4c f3 a1	jmp $a1f3			jmp	 	TIM_NewCommand 				; new command.
.a2ae					_TIMSR_Label:
>a2ae	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR ZR SP",13,".; "
>a2b6	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>a2c6	52 20 5a 52 20 53 50 0d 2e 3b 20
.a2d1					_TIMSR_LabelEnd:
.a2d1					TIM_WriteHex:
.a2d1	48		pha				pha 								; save A
.a2d2	4a		lsr a				lsr 	a 							; shift MSB->LSB
.a2d3	4a		lsr a				lsr 	a
.a2d4	4a		lsr a				lsr 	a
.a2d5	4a		lsr a				lsr 	a
.a2d6	20 da a2	jsr $a2da			jsr 	_TIMWH_Nibble 				; print MSB
.a2d9	68		pla				pla 								; restore and print LSB
.a2da					_TIMWH_Nibble:
.a2da	48		pha				pha
.a2db	29 0f		and #$0f			and 	#15 						; mask out
.a2dd	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.a2df	90 02		bcc $a2e3			bcc 	_TIMWHNoLetter
.a2e1	69 06		adc #$06			adc 	#6
.a2e3					_TIMWHNoLetter:
.a2e3	69 30		adc #$30			adc 	#48
.a2e5	20 7f a0	jsr $a07f			jsr 	IFT_PrintCharacter 			; print it out.
.a2e8	68		pla				pla
.a2e9	60		rts				rts
.a2ea					TIM_WriteLine:
.a2ea	a9 2e		lda #$2e			lda 	#"." 						; prompt
.a2ec	20 7f a0	jsr $a07f			jsr 	IFT_PrintCharacter
.a2ef	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.a2f1	20 7f a0	jsr $a07f			jsr 	IFT_PrintCharacter
.a2f4	a5 13		lda $13				lda 	zTemp2+1 					; write address
.a2f6	20 d1 a2	jsr $a2d1			jsr 	TIM_WriteHex
.a2f9	a5 12		lda $12				lda 	zTemp2
.a2fb	20 d1 a2	jsr $a2d1			jsr 	TIM_WriteHex
.a2fe	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.a300					_TIMWL_Loop:
.a300	a9 20		lda #$20			lda 	#" "
.a302	20 7f a0	jsr $a07f			jsr 	IFT_PrintCharacter
.a305	b1 12		lda ($12),y			lda 	(zTemp2),y
.a307	20 d1 a2	jsr $a2d1			jsr 	TIM_WriteHex
.a30a	c8		iny				iny
.a30b	c0 10		cpy #$10			cpy 	#16
.a30d	d0 f1		bne $a300			bne 	_TIMWL_Loop
.a30f	4c 9b a0	jmp $a09b			jmp 	IFT_NewLine 				; new line and exit
.a312					TIM_GetHex:
.a312	c8		iny				iny
.a313	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.a315	c9 20		cmp #$20			cmp 	#32
.a317	f0 f9		beq $a312			beq 	TIM_GetHex
.a319	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.a31b	f0 f5		beq $a312			beq 	TIM_GetHex
.a31d	20 46 a3	jsr $a346			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.a320	b0 23		bcs $a345			bcs 	_TIMGH_Exit					; if first bad then exit now.
.a322	a9 00		lda #$00			lda 	#0 							; zero result
.a324	85 14		sta $14				sta 	zTemp3
.a326	85 15		sta $15				sta 	zTemp3+1
.a328					_TIM_GHLoop:
.a328	20 46 a3	jsr $a346			jsr 	TIM_GetHexCharacter 		; get next character
.a32b	b0 17		bcs $a344			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.a32d	c8		iny				iny 								; skip over it.
.a32e	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.a330	26 15		rol $15				rol 	zTemp3+1
.a332	06 14		asl $14				asl 	zTemp3 						; now x 2
.a334	26 15		rol $15				rol 	zTemp3+1
.a336	06 14		asl $14				asl 	zTemp3						; now x 4
.a338	26 15		rol $15				rol 	zTemp3+1
.a33a	06 14		asl $14				asl 	zTemp3 						; now x 8
.a33c	26 15		rol $15				rol 	zTemp3+1
.a33e	05 14		ora $14				ora 	zTemp3 						; OR result in
.a340	85 14		sta $14				sta 	zTemp3
.a342	80 e4		bra $a328			bra 	_TIM_GHLoop 				; loop round again.
.a344					_TIMGH_Okay:
.a344	18		clc				clc
.a345					_TIMGH_Exit:
.a345	60		rts				rts
.a346					TIM_GetHexCharacter:
.a346	b1 10		lda ($10),y			lda 	(zTemp1),y
.a348	38		sec				sec
.a349	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.a34b	90 0e		bcc $a35b			bcc 	_TIM_GHCFail
.a34d	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.a34f	90 0b		bcc $a35c			bcc 	_TIM_GHCExit
.a351	c9 11		cmp #$11			cmp 	#65-48						; < A
.a353	90 06		bcc $a35b			bcc		_TIM_GHCFail
.a355	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.a357	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.a359	90 01		bcc $a35c			bcc		_TIM_GHCExit
.a35b					_TIM_GHCFail:
.a35b	38		sec				sec
.a35c					_TIM_GHCExit:
.a35c	60		rts				rts
.a35d					TIM_BreakVector:
.a35d	da		phx				phx									; save X/A on stack
.a35e	48		pha				pha
.a35f	ba		tsx				tsx 								; X points to S
.a360	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.a363	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.a365	d0 03		bne $a36a			bne 	_TIMBreak					; if set, it's BRK
.a367	68		pla				pla 								; abandon routine.
.a368	fa		plx				plx
.a369	40		rti				rti
.a36a					_TIMBreak:
.a36a	68		pla				pla 								; save A X Y and maybe Z
.a36b	8d 05 04	sta $0405			sta 	TIM_A
.a36e	fa		plx				plx
.a36f	8e 06 04	stx $0406			stx 	TIM_X
.a372	8c 07 04	sty $0407			sty 	TIM_Y
.a375	68		pla				pla 								; get Status Register
.a376	8d 04 04	sta $0404			sta 	TIM_SR
.a379	68		pla				pla
.a37a	8d 01 04	sta $0401			sta 	TIM_PC+1 					; save calling address
.a37d	68		pla				pla
.a37e	8d 00 04	sta $0400			sta 	TIM_PC 						; high byte
.a381	ad 01 04	lda $0401			lda 	TIM_PC+1 					; dec PC to point right.
.a384	d0 03		bne $a389			bne 	_TIMDecrement 				; brk bumps it.
.a386	ce 00 04	dec $0400			dec 	TIM_PC
.a389					_TIMDecrement:
.a389	ce 01 04	dec $0401			dec 	TIM_PC+1
.a38c	ba		tsx				tsx 								; and copy SP
.a38d	8e 09 04	stx $0409			stx 	TIM_SP
.a390	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.a392	9a		txs				txs
.a393	4c 75 a2	jmp $a275			jmp 	TIM_Start 					; and start up TIM monitor.
.a396					TIM_UpdateRegisters:
.a396	20 12 a3	jsr $a312			jsr 	TIM_GetHex 					; PC
.a399	b0 23		bcs $a3be			bcs 	_TIMURFail
.a39b	a5 14		lda $14				lda 	zTemp3
.a39d	8d 01 04	sta $0401			sta 	Tim_PC+1
.a3a0	a5 15		lda $15				lda 	zTemp3+1
.a3a2	8d 00 04	sta $0400			sta 	Tim_PC
.a3a5	20 12 a3	jsr $a312			jsr 	TIM_GetHex 					; ignore IRQ
.a3a8	b0 14		bcs $a3be			bcs 	_TIMURFail
.a3aa	a2 00		ldx #$00			ldx 	#0
.a3ac					_TIM_URLoop:
.a3ac	20 12 a3	jsr $a312			jsr 	TIM_GetHex 					; registers
.a3af	b0 0d		bcs $a3be			bcs 	_TIMURFail
.a3b1	a5 14		lda $14				lda 	zTemp3
.a3b3	9d 04 04	sta $0404,x			sta 	Tim_SR,x
.a3b6	e8		inx				inx
.a3b7	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.a3b9	d0 f1		bne $a3ac			bne 	_TIM_URLoop
.a3bb	4c f3 a1	jmp $a1f3			jmp 	TIM_NewCommand
.a3be					_TIMURFail:
.a3be	4c ec a1	jmp $a1ec			jmp 	TIM_Error
.a3c1					TIM_LoadMemory:
.a3c1	20 12 a3	jsr $a312			jsr 	TIM_GetHex 					; target address => zTemp2
.a3c4	a5 14		lda $14				lda 	zTemp3
.a3c6	85 12		sta $12				sta 	zTemp2
.a3c8	a5 15		lda $15				lda 	zTemp3+1
.a3ca	85 13		sta $13				sta 	zTemp2+1
.a3cc					_TIM_LMLoop:
.a3cc	20 12 a3	jsr $a312			jsr 	TIM_GetHex 					; next byte ?
.a3cf	b0 0e		bcs $a3df			bcs 	_TIMLMDone 					; no more
.a3d1	a2 00		ldx #$00			ldx 	#0							; write out.
.a3d3	a5 14		lda $14				lda 	zTemp3
.a3d5	81 12		sta ($12,x)			sta 	(zTemp2,x)
.a3d7	e6 12		inc $12				inc 	zTemp2 						; bump address
.a3d9	d0 f1		bne $a3cc			bne 	_TIM_LMLoop
.a3db	e6 13		inc $13				inc 	zTemp2+1
.a3dd	80 ed		bra $a3cc			bra 	_TIM_LMLoop
.a3df					_TIMLMDone:
.a3df	4c f3 a1	jmp $a1f3			jmp 	TIM_NewCommand

;******  Return to file: basic.asm


;******  Processing file: testing/fptest.asm

.a3e2					FPTTest:
.a3e2	a9 9d		lda #$9d			lda 	#FPTTestData & $FF 			; set zGenPtr to data.
.a3e4	85 1a		sta $1a				sta 	zGenPtr
.a3e6	a9 a4		lda #$a4			lda 	#FPTTestData >> 8
.a3e8	85 1b		sta $1b				sta 	zGenPtr+1
.a3ea	a2 00		ldx #$00			ldx 	#0 							; start at stack bottom.
.a3ec	a5 1b		lda $1b		FPTLoop:lda 	zGenPtr+1
.a3ee	20 d1 a2	jsr $a2d1			jsr 	TIM_WriteHex
.a3f1	a5 1a		lda $1a				lda 	zGenPtr
.a3f3	20 d1 a2	jsr $a2d1			jsr 	TIM_WriteHex
.a3f6	a9 2e		lda #$2e			lda 	#"."
.a3f8	20 7f a0	jsr $a07f			jsr		IFT_PrintCharacter
.a3fb	20 8e a4	jsr $a48e			jsr 	FPTGet 						; get next command
.a3fe	c9 00		cmp #$00			cmp 	#0 							; zero, exit
.a400	f0 58		beq $a45a			beq 	FPTExit
.a402	c9 01		cmp #$01			cmp 	#1 							; 1,load
.a404	f0 46		beq $a44c			beq 	FPTLoad
.a406	c9 2b		cmp #$2b			cmp 	#"+" 						; the -1/0/1 value in AC.
.a408	d0 0b		bne $a415			bne 	_skip1
.a40a	20 82 a4	jsr $a482			jsr 	FPT_Preamble
.a40d	20 48 a6	jsr $a648			jsr 	FPAdd
.a410	20 88 a4	jsr $a488			jsr 	FPT_Postamble
.a413	80 d7		bra $a3ec			bra 	FPTLoop
.a415					_skip1:
.a415	c9 2d		cmp #$2d			cmp 	#"-" 						; the -1/0/1 value in AC.
.a417	d0 0b		bne $a424			bne 	_skip1
.a419	20 82 a4	jsr $a482			jsr 	FPT_Preamble
.a41c	20 3e a6	jsr $a63e			jsr 	FPSubtract
.a41f	20 88 a4	jsr $a488			jsr 	FPT_Postamble
.a422	80 c8		bra $a3ec			bra 	FPTLoop
.a424					_skip1:
.a424	c9 2a		cmp #$2a			cmp 	#"*" 						; the -1/0/1 value in AC.
.a426	d0 0b		bne $a433			bne 	_skip1
.a428	20 82 a4	jsr $a482			jsr 	FPT_Preamble
.a42b	20 18 a7	jsr $a718			jsr 	FPMultiply
.a42e	20 88 a4	jsr $a488			jsr 	FPT_Postamble
.a431	80 b9		bra $a3ec			bra 	FPTLoop
.a433					_skip1:
.a433	c9 2f		cmp #$2f			cmp 	#"/" 						; the -1/0/1 value in AC.
.a435	d0 0b		bne $a442			bne 	_skip1
.a437	20 82 a4	jsr $a482			jsr 	FPT_Preamble
.a43a	20 c9 a7	jsr $a7c9			jsr 	FPDivide
.a43d	20 88 a4	jsr $a488			jsr 	FPT_Postamble
.a440	80 aa		bra $a3ec			bra 	FPTLoop
.a442					_skip1:
.a442	c9 7e		cmp #$7e			cmp 	#"~" 						; ~, compare
.a444	f0 1a		beq $a460			beq 	FPTCompare
.a446	c9 3d		cmp #$3d			cmp 	#"="						; = check equal
.a448	f0 28		beq $a472			beq 	FPTCheck
.a44a					FPTError:
.a44a	80 fe		bra $a44a			bra 	FPTError
.a44c					FPTLoad:
.a44c	a0 06		ldy #$06			ldy 	#6 							; data to copy
.a44e					_FPTLoadLoop:
.a44e	20 8e a4	jsr $a48e			jsr 	FPTGet
.a451	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.a454	e8		inx				inx
.a455	88		dey				dey
.a456	d0 f6		bne $a44e			bne 	_FPTLoadLoop
.a458	80 92		bra $a3ec			bra 	FPTLoop
.a45a					FPTExit:
.a45a	a9 2a		lda #$2a			lda 	#42
.a45c	20 7f a0	jsr $a07f			jsr 	IFT_PrintCharacter
.a45f	60		rts				rts
.a460					FPTCompare:
.a460	20 82 a4	jsr $a482			jsr 	FPT_Preamble
.a463	20 51 a8	jsr $a851			jsr 	FPCompare
.a466	20 d8 a4	jsr $a4d8			jsr 	FPUSetInteger
.a469	20 16 a5	jsr $a516			jsr 	FPUToFloat
.a46c	20 88 a4	jsr $a488			jsr 	FPT_Postamble
.a46f	4c ec a3	jmp $a3ec			jmp 	FPTLoop
.a472					FPTCheck:
.a472	20 82 a4	jsr $a482			jsr 	FPT_Preamble
.a475	20 51 a8	jsr $a851			jsr 	FPCompare
.a478	09 00		ora #$00			ora 	#0
.a47a					_FPTCFail:
.a47a	d0 fe		bne $a47a			bne 	_FPTCFail
.a47c	20 88 a4	jsr $a488			jsr 	FPT_Postamble
.a47f	4c ec a3	jmp $a3ec			jmp 	FPTLoop
.a482					FPT_Preamble:
.a482	8a		txa				txa
.a483	38		sec				sec
.a484	e9 0c		sbc #$0c			sbc 	#12
.a486	aa		tax				tax
.a487	60		rts				rts
.a488					FPT_Postamble:
.a488	8a		txa				txa
.a489	18		clc				clc
.a48a	69 06		adc #$06			adc 	#6
.a48c	aa		tax				tax
.a48d	60		rts				rts
.a48e	5a		phy		FPTGet:	phy
.a48f	a0 00		ldy #$00			ldy 	#0
.a491	b1 1a		lda ($1a),y			lda 	(zGenPtr),y
.a493	48		pha				pha
.a494	e6 1a		inc $1a				inc 	zGenPtr
.a496	d0 02		bne $a49a			bne 	_FPTGet1
.a498	e6 1b		inc $1b				inc 	zGenPtr+1
.a49a					_FPTGet1:
.a49a	68		pla				pla
.a49b	7a		ply				ply
.a49c	60		rts				rts
.a49d					FPTTestData:

;******  Processing file: testing/script.inc

>a49d	01					.byte 	1     ; *** Load Float 99.94 ***
>a49e	ae 47 e1 c7				.dword 	$c7e147ae
>a4a2	87 00					.byte 	$87,$0
>a4a4	01					.byte 	1     ; *** Load Float 1 ***
>a4a5	00 00 00 80				.dword 	$80000000
>a4a9	81 00					.byte 	$81,$0
>a4ab	01					.byte 	1     ; *** Load Float 0.099999 ***
>a4ac	95 46 cc cc				.dword 	$cccc4695
>a4b0	7d 00					.byte 	$7d,$0
>a4b2	2b					.byte 	$2b   ; *** Command + ***
>a4b3	01					.byte 	1     ; *** Load Float 0.1 ***
>a4b4	cc cc cc cc				.dword 	$cccccccc
>a4b8	7d 00					.byte 	$7d,$0
>a4ba	2b					.byte 	$2b   ; *** Command + ***
>a4bb	01					.byte 	1     ; *** Load Float 1.2 ***
>a4bc	99 99 99 99				.dword 	$99999999
>a4c0	81 00					.byte 	$81,$0
>a4c2	3d					.byte 	$3d   ; *** Command = ***
>a4c3	00					.byte 	0

;******  Return to file: testing/fptest.asm

>a4c4	00						.byte 	0

;******  Return to file: basic.asm


;******  Processing file: float/fpmacros.asm


;******  Return to file: basic.asm


;******  Processing file: float/fputils.asm

.a4c5					FPUCopyX2ToX1:
.a4c5	48		pha				pha
.a4c6	da		phx				phx
.a4c7	5a		phy				phy
.a4c8	a0 08		ldy #$08			ldy 	#8
.a4ca	bd 06 03	lda $0306,x	_FPUC21:lda 	XS2_Mantissa,x
.a4cd	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.a4d0	e8		inx				inx
.a4d1	88		dey				dey
.a4d2	10 f6		bpl $a4ca			bpl 	_FPUC21
.a4d4	7a		ply				ply
.a4d5	fa		plx				plx
.a4d6	68		pla				pla
.a4d7	60		rts				rts
.a4d8					FPUSetInteger:
.a4d8	48		pha				pha
.a4d9	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.a4dc	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.a4de	10 02		bpl $a4e2			bpl 	_FPUSIExtend
.a4e0	a9 ff		lda #$ff			lda 	#$FF
.a4e2					_FPUSIExtend:
.a4e2	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.a4e5	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.a4e8	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.a4eb	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.a4ed	9d 05 03	sta $0305,x			sta 	XS_Type,x
.a4f0	68		pla				pla
.a4f1	60		rts				rts
.a4f2					FPUNegateInteger:
.a4f2	48		pha				pha
.a4f3	38		sec				sec
.a4f4	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.a4f6	fd 00 03	sbc $0300,x			sbc 	XS_Mantissa+0,x
.a4f9	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.a4fc	a9 00		lda #$00			lda 	#0
.a4fe	fd 01 03	sbc $0301,x			sbc 	XS_Mantissa+1,x
.a501	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.a504	a9 00		lda #$00			lda 	#0
.a506	fd 02 03	sbc $0302,x			sbc 	XS_Mantissa+2,x
.a509	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.a50c	a9 00		lda #$00			lda 	#0
.a50e	fd 03 03	sbc $0303,x			sbc 	XS_Mantissa+3,x
.a511	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.a514	68		pla				pla
.a515	60		rts				rts
.a516					FPUToFloat:
.a516	48		pha				pha
.a517	bd 05 03	lda $0305,x			lda 	XS_Type,x					; exit if already float.
.a51a	29 0f		and #$0f			and 	#$0F
.a51c	f0 2d		beq $a54b			beq 	_FPUFExit
.a51e	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.a520	9d 05 03	sta $0305,x			sta 	XS_Type,x
.a523	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.a525	9d 04 03	sta $0304,x			sta 	XS_Exponent,x 				; x mantissa.
.a528	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.a52b	10 08		bpl $a535			bpl		_FPUFPositive
.a52d	20 f2 a4	jsr $a4f2			jsr 	FPUNegateInteger 			; negate the mantissa
.a530	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.a532	9d 05 03	sta $0305,x			sta 	XS_Type,x
.a535					_FPUFPositive:
.a535	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.a538	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.a53b	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.a53e	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.a541	d0 05		bne $a548			bne 	_FPUFNonZero
.a543	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.a545	9d 05 03	sta $0305,x			sta 	XS_Type,x
.a548					_FPUFNonZero:
.a548	20 4d a5	jsr $a54d			jsr 	FPUNormalise 				; normalise the floating point.
.a54b					_FPUFExit:
.a54b	68		pla				pla
.a54c	60		rts				rts
.a54d					FPUNormalise:
.a54d	48		pha				pha
.a54e	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.a551	70 20		bvs $a573			bvs 	_FPUNExit
.a553	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.a556	f0 16		beq $a56e			beq 	_FPUNSetZero
.a558					_FPUNLoop:
.a558	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.a55b	30 16		bmi $a573			bmi 	_FPUNExit 					; if so, we are normalised.
.a55d	1e 00 03	asl $0300,x			asl 	0+XS_Mantissa+0,x
.a560	3e 01 03	rol $0301,x			rol 	1+XS_Mantissa+0,x
.a563	3e 02 03	rol $0302,x			rol 	2+XS_Mantissa+0,x
.a566	3e 03 03	rol $0303,x			rol 	3+XS_Mantissa+0,x
.a569	de 04 03	dec $0304,x			dec 	XS_Exponent,x 				; decrement exponent
.a56c	d0 ea		bne $a558			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.a56e					_FPUNSetZero:
.a56e	a9 40		lda #$40			lda 	#$40
.a570	9d 05 03	sta $0305,x			sta 	XS_Type,x 					; the result is now zero.
.a573					_FPUNExit:
.a573	68		pla				pla
.a574	60		rts				rts
.a575					FPUToInteger:
.a575	48		pha				pha
.a576	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; if already integer, exit
.a579	29 01		and #$01			and 	#1
.a57b	d0 3e		bne $a5bb			bne 	_FPUTOI_Exit
.a57d	3c 05 03	bit $0305,x			bit 	XS_Type,x					; if zero, return zero.
.a580	70 2b		bvs $a5ad			bvs 	_FPUTOI_Zero
.a582	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.a585	10 26		bpl $a5ad			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.a587	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.a589	b0 37		bcs $a5c2			bcs 	FP_Overflow
.a58b					_FPUToIToInteger:
.a58b	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.a58e	c9 a0		cmp #$a0			cmp 	#128+32
.a590	f0 11		beq $a5a3			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.a592	fe 04 03	inc $0304,x			inc 	XS_Exponent,X 				; increment Exponent
.a595	5e 03 03	lsr $0303,x			lsr 	3+XS_Mantissa,x
.a598	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.a59b	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.a59e	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.a5a1	80 e8		bra $a58b			bra 	_FPUToIToInteger 			; keep going.
.a5a3					_FPUToICheckSign:
.a5a3	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; check sign
.a5a6	10 13		bpl $a5bb			bpl 	_FPUToI_Exit 				; exit if unsigned.
.a5a8	20 f2 a4	jsr $a4f2			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.a5ab	80 0e		bra $a5bb			bra 	_FPUTOI_Exit
.a5ad					_FPUTOI_Zero:
.a5ad	a9 00		lda #$00			lda 	#0 							; return zero integer.
.a5af	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.a5b2	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.a5b5	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.a5b8	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.a5bb					_FPUToI_Exit:
.a5bb	a9 01		lda #$01			lda 	#1 							; set type to integer
.a5bd	9d 05 03	sta $0305,x			sta 	XS_Type,x
.a5c0	68		pla				pla
.a5c1	60		rts				rts
.a5c2					FP_Overflow:
.a5c2	20 a1 a8	jsr $a8a1			jsr 	ERR_Handler
>a5c5	46 6c 6f 61 74 69 6e 67				.text 	"Floating Point overflow",0
>a5cd	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.a5dd					FPUTimes10:
.a5dd	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.a5e0	85 16		sta $16				sta 	ZLTemp1+0
.a5e2	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.a5e5	85 17		sta $17				sta 	ZLTemp1+1
.a5e7	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.a5ea	85 18		sta $18				sta 	ZLTemp1+2
.a5ec	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.a5ef	85 19		sta $19				sta 	ZLTemp1+3
.a5f1	20 35 a6	jsr $a635			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.a5f4	20 35 a6	jsr $a635			jsr 	_FPUT_LSR_ZLTemp1
.a5f7	18		clc				clc
.a5f8	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.a5fb	65 16		adc $16				adc 	ZLTemp1+0
.a5fd	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.a600	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.a603	65 17		adc $17				adc 	ZLTemp1+1
.a605	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.a608	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.a60b	65 18		adc $18				adc 	ZLTemp1+2
.a60d	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.a610	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.a613	65 19		adc $19				adc 	ZLTemp1+3
.a615	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.a618	90 0f		bcc $a629			bcc 	_FPUTimes10
.a61a	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.a61d	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.a620	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.a623	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.a626	fe 04 03	inc $0304,x			inc 	XS_Exponent,x				; fix exponent
.a629					_FPUTimes10:
.a629	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.a62c	18		clc				clc
.a62d	69 03		adc #$03			adc 	#3
.a62f	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.a632	b0 8e		bcs $a5c2			bcs 	FP_Overflow 				; error
.a634	60		rts				rts
.a635					_FPUT_LSR_ZLTemp1:
.a635	46 19		lsr $19				lsr 	ZLTemp1+3
.a637	66 18		ror $18				ror 	ZLTemp1+2
.a639	66 17		ror $17				ror 	ZLTemp1+1
.a63b	66 16		ror $16				ror 	ZLTemp1+0
.a63d	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: float/fpadd.asm

.a63e					FPSubtract:
.a63e	48		pha				pha
.a63f	bd 0b 03	lda $030b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.a642	49 80		eor #$80			eor 	#$80
.a644	9d 0b 03	sta $030b,x			sta 	XS2_Type,x
.a647	68		pla				pla 								; --- and fall through ---
.a648					FPAdd:
.a648	48		pha				pha
.a649	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.a64c	d0 05		bne $a653			bne 	_FPA_NegativeLHS
.a64e	20 70 a6	jsr $a670			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.a651	68		pla				pla
.a652	60		rts				rts
.a653					_FPA_NegativeLHS:
.a653	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.a656	49 80		eor #$80			eor 	#$80
.a658	9d 05 03	sta $0305,x			sta 	XS_Type,x
.a65b	bd 0b 03	lda $030b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.a65e	49 80		eor #$80			eor 	#$80
.a660	9d 0b 03	sta $030b,x			sta 	XS2_Type,x
.a663	20 70 a6	jsr $a670			jsr 	FPAdd_Worker 				; do the add calculation.
.a666	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip sign of X1 back
.a669	49 80		eor #$80			eor 	#$80
.a66b	9d 05 03	sta $0305,x			sta 	XS_Type,x
.a66e	68		pla				pla
.a66f	60		rts				rts
.a670					FPAdd_Worker:
.a670	3c 0b 03	bit $030b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.a673	70 08		bvs $a67d			bvs 	_FPAWExit 					; no change.
.a675	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.a678	50 07		bvc $a681			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.a67a	20 c5 a4	jsr $a4c5			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.a67d					_FPAWExit:
.a67d	20 4d a5	jsr $a54d			jsr 	FPUNormalise 				; normalise the result.
.a680	60		rts				rts
.a681					_FPAWMakeSame:
.a681	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.a684	38		sec				sec
.a685	fd 0a 03	sbc $030a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.a688	f0 1b		beq $a6a5			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.a68a	da		phx				phx 								; save X
.a68b	90 06		bcc $a693			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.a68d	e8		inx				inx
.a68e	e8		inx				inx
.a68f	e8		inx				inx
.a690	e8		inx				inx
.a691	e8		inx				inx
.a692	e8		inx				inx
.a693					_FPAWShiftA:
.a693	fe 04 03	inc $0304,x			inc 	XS_Exponent,x 				; so shift exponent up.
.a696	5e 03 03	lsr $0303,x			lsr 	3+XS_Mantissa,x
.a699	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.a69c	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.a69f	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.a6a2	fa		plx				plx 								; restore original X
.a6a3	80 dc		bra $a681			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.a6a5					_FPAW_DoArithmetic:
.a6a5	3c 0b 03	bit $030b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.a6a8	30 39		bmi $a6e3			bmi 	_FPAW_BNegative
.a6aa	18		clc				clc
.a6ab	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.a6ae	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.a6b1	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.a6b4	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.a6b7	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.a6ba	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.a6bd	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.a6c0	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.a6c3	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.a6c6	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.a6c9	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.a6cc	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.a6cf	90 ac		bcc $a67d			bcc 	_FPAWExit 					; no carry.
.a6d1	fe 04 03	inc $0304,x			inc 	XS_Exponent,x 				; so shift exponent up.
.a6d4	38		sec				sec
.a6d5	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.a6d8	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.a6db	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.a6de	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.a6e1	80 9a		bra $a67d			bra 	_FPAWExit
.a6e3					_FPAW_BNegative:
.a6e3	38		sec				sec
.a6e4	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.a6e7	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.a6ea	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.a6ed	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.a6f0	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.a6f3	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.a6f6	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.a6f9	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.a6fc	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.a6ff	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.a702	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.a705	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.a708	b0 0b		bcs $a715			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.a70a	20 f2 a4	jsr $a4f2			jsr 	FPUNegateInteger			; negate the mantissa
.a70d	ad 05 03	lda $0305			lda 	XS_Type 					; flip result sign
.a710	49 80		eor #$80			eor 	#$80
.a712	8d 05 03	sta $0305			sta 	XS_Type
.a715					_FPAWGoExit:
.a715	4c 7d a6	jmp $a67d			jmp 	_FPAWExit

;******  Return to file: basic.asm


;******  Processing file: float/fpmultiply.asm

.a718					FPMultiply:
.a718	48		pha				pha
.a719	5a		phy				phy
.a71a	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.a71d	70 08		bvs $a727			bvs 	_FPM_Exit
.a71f	3c 0b 03	bit $030b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.a722	50 06		bvc $a72a			bvc 	_FPM_CalcExponent
.a724	20 c5 a4	jsr $a4c5			jsr 	FPUCopyX2ToX1
.a727					_FPM_Exit:
.a727	7a		ply				ply
.a728	68		pla				pla
.a729	60		rts				rts
.a72a					_FPM_CalcExponent:
.a72a	18		clc				clc
.a72b	20 9c a7	jsr $a79c			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.a72e	9d 04 03	sta $0304,x			sta 	XS_Exponent,x 				; save the result.
.a731	a9 00		lda #$00			lda 	#0
.a733	85 16		sta $16				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.a735	85 17		sta $17				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.a737	85 18		sta $18				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.a739	85 19		sta $19				sta 	zLTemp1+3
.a73b	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.a73d					_FPM_Loop:
.a73d	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x				; check LSB of long product
.a740	29 01		and #$01			and 	#1
.a742	18		clc				clc 								; clear carry for the long rotate.
.a743	f0 1d		beq $a762			beq 	_FPM_NoAddition
.a745	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.a746	a5 16		lda $16				lda 	zLTemp1+0
.a748	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.a74b	85 16		sta $16				sta 	zLTemp1+0
.a74d	a5 17		lda $17				lda 	zLTemp1+1
.a74f	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.a752	85 17		sta $17				sta 	zLTemp1+1
.a754	a5 18		lda $18				lda 	zLTemp1+2
.a756	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.a759	85 18		sta $18				sta 	zLTemp1+2
.a75b	a5 19		lda $19				lda 	zLTemp1+3
.a75d	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.a760	85 19		sta $19				sta 	zLTemp1+3
.a762					_FPM_NoAddition:
.a762	66 19		ror $19				ror 	3+zLTemp1
.a764	66 18		ror $18				ror 	2+zLTemp1
.a766	66 17		ror $17				ror 	1+zLTemp1
.a768	66 16		ror $16				ror 	0+zLTemp1
.a76a	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.a76d	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.a770	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.a773	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.a776	88		dey				dey
.a777	d0 c4		bne $a73d			bne 	_FPM_Loop 					; do this 32 times.
.a779					FPM_CopySignNormalize:
.a779	a5 16		lda $16				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.a77b	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.a77e	a5 17		lda $17				lda 	zLTemp1+1
.a780	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.a783	a5 18		lda $18				lda 	zLTemp1+2
.a785	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.a788	a5 19		lda $19				lda 	zLTemp1+3
.a78a	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.a78d	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; sign is xor of signs
.a790	5d 0b 03	eor $030b,x			eor 	XS2_Type,x
.a793	9d 05 03	sta $0305,x			sta 	XS_Type,x
.a796	20 4d a5	jsr $a54d			jsr 	FPUNormalise 				; normalise and exit.
.a799	7a		ply				ply
.a79a	68		pla				pla
.a79b	60		rts				rts
.a79c					FPCalculateExponent:
.a79c	18		clc				clc
.a79d	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.a7a0	7d 0a 03	adc $030a,x			adc 	XS2_Exponent,x
.a7a3	b0 08		bcs $a7ad			bcs 	_FPCECarry 					; carry out ?
.a7a5	10 03		bpl $a7aa			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.a7a7	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.a7a9	60		rts				rts
.a7aa					_FPCEExpZero:
.a7aa	a9 00		lda #$00			lda 	#0
.a7ac	60		rts				rts
.a7ad					_FPCECarry:
.a7ad	30 03		bmi $a7b2			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.a7af	09 80		ora #$80			ora 	#$80 						; put in right range
.a7b1	60		rts				rts
.a7b2					_FPCEOverflow:
.a7b2	4c c2 a5	jmp $a5c2			jmp 	FP_Overflow

;******  Return to file: basic.asm


;******  Processing file: float/fpdivide.asm

.a7b5					FPD_IsDivZero:
.a7b5	20 a1 a8	jsr $a8a1			jsr 		ERR_Handler
>a7b8	44 69 76 69 73 69 6f 6e				.text 		"Division by zero",0
>a7c0	20 62 79 20 7a 65 72 6f 00
.a7c9					FPDivide:
.a7c9	48		pha				pha
.a7ca	5a		phy				phy
.a7cb	3c 0b 03	bit $030b,x			bit 	XS2_Type,x 					; check if division by zero
.a7ce	70 e5		bvs $a7b5			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.a7d0	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.a7d3	f0 03		beq $a7d8			beq 	_FPDCalculateExp
.a7d5					_FPD_Exit:
.a7d5	7a		ply				ply
.a7d6	68		pla				pla
.a7d7	60		rts				rts
.a7d8					_FPDCalculateExp:
.a7d8	bd 0a 03	lda $030a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.a7db	49 ff		eor #$ff			eor 	#$FF
.a7dd	1a		inc a				inc 	a
.a7de	9d 0a 03	sta $030a,x			sta 	XS2_Exponent,x
.a7e1	20 9c a7	jsr $a79c			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.a7e4	18		clc				clc 	 							; add 1 to the resulting exponent
.a7e5	69 01		adc #$01			adc 	#1
.a7e7	b0 65		bcs $a84e			bcs 	_FPD_Overflow 				; which can overflow.
.a7e9	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.a7ec	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.a7ee	85 16		sta $16				sta 	zLTemp1+0
.a7f0	85 17		sta $17				sta 	zLTemp1+1
.a7f2	85 18		sta $18				sta 	zLTemp1+2
.a7f4	85 19		sta $19				sta 	zLTemp1+3
.a7f6	a0 20		ldy #$20			ldy 	#32 						; times round.
.a7f8					_FPD_Loop:
.a7f8	38		sec				sec 								; calculate X1-X2 stacking result because we might
.a7f9	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 				; not save it.
.a7fc	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa,x
.a7ff	48		pha				pha
.a800	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.a803	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.a806	48		pha				pha
.a807	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.a80a	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.a80d	48		pha				pha
.a80e	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.a811	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.a814	90 17		bcc $a82d			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.a816	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x 			; save results out to A
.a819	68		pla				pla
.a81a	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.a81d	68		pla				pla
.a81e	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.a821	68		pla				pla
.a822	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.a825	a5 19		lda $19				lda 	zLTemp1+3 					; set high bit of result
.a827	09 80		ora #$80			ora 	#$80
.a829	85 19		sta $19				sta 	zLTemp1+3
.a82b	80 03		bra $a830			bra 	_FPD_Rotates
.a82d					_FPD_NoSubtract:
.a82d	68		pla				pla 								; throw away unwanted results
.a82e	68		pla				pla
.a82f	68		pla				pla
.a830					_FPD_Rotates:
.a830	5e 09 03	lsr $0309,x			lsr 	3+XS2_Mantissa,x
.a833	7e 08 03	ror $0308,x			ror 	2+XS2_Mantissa,x
.a836	7e 07 03	ror $0307,x			ror 	1+XS2_Mantissa,x
.a839	7e 06 03	ror $0306,x			ror 	0+XS2_Mantissa,x
.a83c	06 16		asl $16				asl 	zLTemp1 					; rotate result round left
.a83e	26 17		rol $17				rol 	zLTemp1+1
.a840	26 18		rol $18				rol 	zLTemp1+2
.a842	26 19		rol $19				rol 	zLTemp1+3
.a844	90 02		bcc $a848			bcc 	_FPD_NoCarry
.a846	e6 16		inc $16				inc 	zLTemp1 					; if rotated out, set LSB.
.a848					_FPD_NoCarry:
.a848	88		dey				dey 								; do 32 times
.a849	d0 ad		bne $a7f8			bne 	_FPD_Loop
.a84b	4c 79 a7	jmp $a779			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.a84e					_FPD_Overflow:
.a84e	4c c2 a5	jmp $a5c2			jmp 	FP_Overflow

;******  Return to file: basic.asm


;******  Processing file: float/fpcompare.asm

.a851					FPCompare:
.a851	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.a854	48		pha				pha
.a855	bd 0a 03	lda $030a,x			lda 	XS2_Exponent,x
.a858	48		pha				pha
.a859	20 3e a6	jsr $a63e			jsr 	FPSubtract 					; calculate X1-X2
.a85c	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.a85f	70 2c		bvs $a88d			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.a861	68		pla				pla
.a862	8d 0a 04	sta $040a			sta 	ExpTemp						; save first exponent in temporary reg.
.a865	68		pla				pla
.a866	38		sec				sec
.a867	ed 0a 04	sbc $040a			sbc 	ExpTemp 					; calculate AX-BX
.a86a	70 15		bvs $a881			bvs 	_FPCNotEqual				; overflow, can't be equal.
.a86c	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.a86d	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.a86f	b0 10		bcs $a881			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.a871	38		sec				sec
.a872	ad 0a 04	lda $040a			lda 	ExpTemp 					; get one of the exponents back.
.a875	e9 16		sbc #$16			sbc 	#22 						; allow for 2^22 error, relatively.
.a877	b0 02		bcs $a87b			bcs 	_FPCNotRange 				; keep in range.
.a879	a9 01		lda #$01			lda 	#1
.a87b					_FPCNotRange:
.a87b	38		sec				sec
.a87c	fd 04 03	sbc $0304,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.a87f	b0 0e		bcs $a88f			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.a881					_FPCNotEqual:
.a881	bd 05 03	lda $0305,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.a884	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.a886	f0 02		beq $a88a			beq 	_FPCNE2
.a888	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.a88a	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.a88b	80 04		bra $a891			bra 	_FPCExit
.a88d					_FPCPullZero:
.a88d	68		pla				pla 								; throw saved exponents
.a88e	68		pla				pla
.a88f					_FPCZero:
.a88f	a9 00		lda #$00			lda 	#0 							; and return zero
.a891					_FPCExit:
.a891	60		rts				rts

;******  Return to file: basic.asm

.a892					StartROM:
.a892	a2 ff		ldx #$ff			ldx 	#$FF 						; empty stack
.a894	9a		txs				txs
.a895	20 00 a0	jsr $a000			jsr 	IF_Reset 					; reset external interface
.a898	20 4a a0	jsr $a04a			jsr 	IFT_ClearScreen
.a89b	20 e2 a3	jsr $a3e2			jsr 	FPTTest
>a89e	5c						.byte 	$5C
.a89f	80 fe		bra $a89f	freeze:	bra 	freeze
.a8a1					ERR_Handler:
.a8a1	80 fe		bra $a8a1			bra 	ERR_Handler
.a8a3					NMIHandler:
.a8a3	40		rti				rti
>fffa	a3 a8						.word	NMIHandler
>fffc	92 a8						.word 	StartROM
>fffe	5d a3						.word 	TIM_BreakVector

;******  End of listing
